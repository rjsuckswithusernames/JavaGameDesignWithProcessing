/* autogenerated by Processing revision 1286 on 2023-05-31 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.concurrent.*;
import processing.sound.*;
import java.util.Random;
import java.util.List;
import java.util.ArrayList;
import java.awt.Color;
import java.awt.Polygon;
import java.awt.Point;
import java.util.ArrayList;
import java.awt.Polygon;
import java.awt.Point;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Game extends PApplet {

/* Game Class Starter File
 * Last Edit: 12/13/2022
 * Authors: Raymond Morel, Muhammad Zahid
 */




//GAME VARIABLES
private int msElapsed = 0;
boolean canpause = true;
protected int gamestate = 0; // 0: Main Menu, 1: Game, 2: Paused, 3: Game-Over

int maximumx = 11;
int maximumy = 13;
int lastTime = 0;
int delta = 0;
protected Grid grid = new Grid(maximumx,maximumy);
PImage bg;

Player player1;
Player player2;
PImage endScreen;
String titleText = "Fire Fighters";
String extraText = "real";
AnimatedSprite exampleSprite;
boolean doAnimation;
Block[][] blocklist;
protected int[][] dirs = 
{
  {-1,0}, //up
  {1,0}, //down
  {0,-1}, //left
  {0,1} //right
};
ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
protected String[] powers = {
  //COMMON ITEMS
  "Skates", // Move Faster. 
  "Hose", // +1 to Explosion Radius.
  "SpareBalloon", //+1 to MaxBalloons.
  "Skates",
  "Hose",
  "SpareBalloon",
  "Skates",
  "Hose",
  "SpareBalloon",
  "Skates",
  "Hose",
  "SpareBalloon",
  "Skates",
  "Hose",
  "SpareBalloon",
  "Skates",
  "Hose",
  "SpareBalloon",
  "Skates",
  "Hose",
  "SpareBalloon",
  //UNCOMMON ITEMS
  "HardHat", // Makes you immune to your own balloon explosions.
  "BoxingGlove", // Allows you to push your own bombs.
  "Raincoat", // +1 Life. 
  "Hydrogen", // Balloons are stronger.
  "HardHat", 
  "BoxingGlove", 
  "Raincoat",
  "Hydrogen", 
  "HardHat", 
  "BoxingGlove", 
  "Raincoat",
  "Hydrogen", 
  //RARE ITEMS
  "PiercingBalloon", // Allows Balloon explosions to pierce through walls.
  "RollerBlades", // Max Speed.
  "PackOfBalloons", // Max Amount of Balloons.
  "Sponge", // +3 Lives.
  "WaterTank", // Max Explosion Radius.
  //Uh Oh!
  "balloon", // because im evil :)
  "balloon",
  "balloon"

};
protected String[] rarepowers = {
  "PiercingBalloon",
  "RollerBlades",
  "PackOfBalloons",
  "Sponge",
  "WaterTank"
};

//SOUNDS

//SoundFile splash;
SoundFile pausesound;
SoundFile kicksound;
SoundFile placeSound;
SoundFile boomSound;
SoundFile lifeSound;
//INPUTS



//P1
int[] p1movekeys = {
  87, //up
  65, //left
  83, //down
  68 //right
};
int ekey = 69;
boolean p1movedebounce = false;
//P2
int[] p2movekeys = {
  38, //up
  37, //left
  40, //down
  39 //right
};
int space = 32;
boolean p2movedebounce = false;

int esc = 27;
//SoundFile song;



//Required Processing method that gets run once
 public void setup() {
  frameRate(60);
  //Match the screen size to the background image size
  /* size commented out by preprocessor */;
  //Set the title on the title bar
  surface.setTitle(titleText);
  //Load images used
  //bg = loadImage("images/chess.jpg");
  bg = loadImage("images/werksugvfuywegg.jpg");
  bg.resize(800,600);
  endScreen = loadImage("images/youwin.png");
  reset();
  pausesound = new SoundFile(this, "sounds/Pause.wav");
  kicksound = new SoundFile(this, "sounds/Kick.wav");
  placeSound = new SoundFile(this, "sounds/Place.wav");
  boomSound = new SoundFile(this, "sounds/Boom.wav");
  lifeSound = new SoundFile(this, "sounds/1up.wav");
  // Load a soundfile from the /data folder of the sketch and play it back
  // song = new SoundFile(this, "sounds/Lenny_Kravitz_Fly_Away.mp3");
  // song.play();
  //splash = new SoundFile(this,"sounds/splash.wav");

  //splash.play();

  
  //Animation & Sprite setup
  exampleAnimationSetup();

  imageMode(CORNER);    //Set Images to read coordinates at corners
  //fullScreen();   //only use if not using a specfic bg image
  
  println("Game started...");

}

//Required Processing method that automatically loops
//(Anything drawn on the screen should be called from here)
 public void draw() {
  delta = millis() - lastTime;
  updateTitleBar();
  if (gamestate == 0){
    initgame();
  } else{
    playinggame(delta);
  }
  lastTime = millis();
  msElapsed+=(1/60);
}

//Known Processing method that automatically will run whenever a key is pressed
 public void keyPressed(){

  //check what key was pressed
  System.out.println("Key pressed: " + keyCode); //keyCode gives you an integer for the key

  //What to do when a key is pressed?
  
  //player 1 movement
  if (gamestate == 1){
  if(keyCode == p1movekeys[0] || keyCode == p1movekeys[1] || keyCode == p1movekeys[2] || keyCode == p1movekeys[3]){
    if (player1.getMoveTimer() <= 0){
      movePlayer(player1,player2,p1movekeys,keyCode);
    }
    else if (player1.getMoveTimer() <= player1.getMaxMoveTimer()/1.25f && p1movedebounce == false){
      p1movedebounce = true;
      int key = keyCode;
      Runnable movement = () -> movePlayer(player1,player2,p1movekeys,key);
      executorService.schedule(movement, player1.getMoveTimer(), TimeUnit.MILLISECONDS);
    }
  }
  if (keyCode == ekey && !(blocklist[player1.getX()][player1.getY()] != null && blocklist[player1.getX()][player1.getY()].getLocation().equals(player1.getLocation())) && player1.getBombs() < player1.getMaxBombs()) {
    placeBomb(player1);
  }
  //Player2 movement

  if(keyCode == p2movekeys[0] || keyCode == p2movekeys[1] || keyCode == p2movekeys[2] || keyCode == p2movekeys[3]){
    if (player2.getMoveTimer() <= 0){
      movePlayer(player2,player1,p2movekeys,keyCode);
    }
    else if (player2.getMoveTimer() <= player2.getMaxMoveTimer()/1.25f && p2movedebounce == false){
      p2movedebounce = true;
      int key = keyCode;
      Runnable movement = () -> movePlayer(player2,player1,p2movekeys,key);
      executorService.schedule(movement, player2.getMoveTimer(), TimeUnit.MILLISECONDS);
    }
  } //end Player2movement
  if (keyCode == space && !(blocklist[player2.getX()][player2.getY()] != null && blocklist[player2.getX()][player2.getY()].getLocation().equals(player2.getLocation())) && player2.getBombs() < player2.getMaxBombs()) {
    placeBomb(player2);
  }
  if (keyCode == esc){
    key = 0;
    if (canpause == true){
      canpause = false;
      gamestate = 2;
      Runnable pause = () -> resetPause();
      executorService.schedule(pause, 500, TimeUnit.MILLISECONDS);
      pausesound.play();
    }

    
  }
  }
  if (gamestate != 1 ){
    if (keyCode == esc){
      key = 0;
      if (canpause == true){
      canpause = false;
      if (gamestate != 2){
        reset();
      }
      else{
        pausesound.play();
      }
      gamestate = 1;
      Runnable pause = () -> resetPause();
      executorService.schedule(pause, 500, TimeUnit.MILLISECONDS);
      }
    }
  }
}
  
  //Known Processing method that automatically will run when a mouse click triggers it
   public void mouseClicked(){
  
    //check if click was successful
    System.out.println("Mouse was clicked at (" + mouseX + "," + mouseY + ")");
    System.out.println("Grid location: " + grid.getGridLocation());

    //what to do if clicked? (Make player1 disappear?)
    if (gamestate != 1){
      if (gamestate != 2){
        reset();
      }
      else  {
          pausesound.play();
      }
      gamestate = 1;
    }

    //Toggle the animation on & off
    //doAnimation = !doAnimation;
    //System.out.println("doAnimation: " + doAnimation);
    //grid.setMark("X",grid.getGridLocation());
    
  }
   public void initgame(){
    background(bg);
    textSize(64);
    textAlign(CENTER);
    text("Click to start", 800/2, 600/2);
  }
 public void playinggame(int dt){

  if (msElapsed % 300 == 0) {
    populateSprites();
    moveSprites();
  }

  updateScreen();
  

  checkExampleAnimation();
  //println(dt);
  if (gamestate == 1){
    update(dt);
  }
  msElapsed +=(1/60);
  //grid.pause(1/30);
  if (isGameOver() && gamestate != 3){
    gamestate = 3;
  }
  if (gamestate == 2){
    textSize(64);
    textAlign(CENTER);
    text("Paused", 800/2, 600/2);
  }
  if (gamestate == 3){
    textSize(64);
    textAlign(CENTER);
    if (player2.isLiving() && !(player1.isLiving())){
      text("Player 2 Wins!", 800/2, 600/2);
    } else if (!(player2.isLiving()) && player1.isLiving()) {
      text("Player 1 Wins!", 800/2, 600/2);
    } else {
      text("Tie!", 800/2, 600/2);
    }
  }
  }

   public void reset(){
    grid.resetBList();
    grid.resetLootTimer();
    grid.generateLevel();
    PImage p1image = loadImage("images/x_wood.png");
    p1image.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
    PImage p2image = loadImage("images/spook.png");
    p2image.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
    player1 = new Player(p1image);
    player2 = new Player(p2image,maximumx-1,maximumy-1);
    Block[][] blocklist = grid.getBList();
  }

  public void update(int dt){
    grid.update(dt);
    for (int r = 0; r < blocklist.length; r++){
      for (int c = 0; c < blocklist[r].length; c++){
          if (blocklist[r][c] != null && blocklist[r][c].isAbleToUpdate() == true){
          Block b = blocklist[r][c];
          b.update(dt);
        }
      }
    }
    player1.update(dt);
    player2.update(dt);
  }


//------------------ CUSTOM  METHODS --------------------//

//method to update the Title Bar of the Game
public void updateTitleBar(){

  if(!isGameOver()) {
    //set the title each loop
    surface.setTitle(titleText + "    " + extraText);

    //adjust the extra text as desired
  
  }

}

//method to update what is drawn on the screen each frame
public void updateScreen(){

  //update the background
  background(bg);

  //Display the Player1 image
  GridLocation player1Loc = new GridLocation(player1.getX(), player1.getY());
  grid.setTileImage(player1Loc, player1.getImage());
    GridLocation player2loc = new GridLocation(player2.getX(), player2.getY());
    grid.setTileImage(player2loc,player2.getImage());
    blocklist = grid.getBList();
    for (int x = 0; x < grid.getNumRows(); x++){
      for (int y = 0; y < grid.getNumCols(); y++){
        Block b = blocklist[x][y];
        if (b != null){
        GridLocation bloc = b.getLocation();
        grid.setTileImage(bloc,b.getImage());
        }
      }
    }

  //Loop through all the Tiles and display its images/sprites
  

      //Store temporary GridLocation
      
      //Check if the tile has an image/sprite 
      //--> Display the tile's image/sprite



  //update other screen elements

}
   public void resetPause(){
    canpause = true;
  }
//Method to populate enemies or other sprites on the screen
public void populateSprites(){
  
  //What is the index for the last column?
  

  //Loop through all the rows in the last column
  
    //Generate a random number
    

    //10% of the time, decide to add an enemy image to a Tile
    

}

//Method to move around the enemies/sprites on the screen
public void moveSprites(){
  //Loop through all of the rows & cols in the grid
  
    //Store the 2 tile locations to move

    //Check if the current tile has an image that is not player1      


      //Get image/sprite from current location


      //CASE 1: Collision with player1


      //CASE 2: Move enemy over to new location

      
      //Erase image/sprite from old location
      
      //System.out.println(loc + " " + grid.hasTileImage(loc));


    //CASE 3: Enemy leaves screen at first column


}
public void movePlayer(Player moving, Player opponent, int[] keys, int keyCode){
    blocklist = grid.getBList();
    //check case where out of bounds
    //change the field for player1Row
    int x = moving.getX();
    int y = moving.getY();
   if (keyCode == keys[0] && moving.getX() > 0 && !(moving.getX()-1 == opponent.getX() && moving.getY()  == opponent.getY()) ){
    x--;
   }
   if (keyCode == keys[1] && moving.getY()  > 0 && !(moving.getY()-1 == opponent.getY() && moving.getX() == opponent.getX())) {
    y--;
   }
   if (keyCode == keys[2] && moving.getX() < grid.getNumRows()-1 && !(moving.getX()+1 == opponent.getX() && moving.getY()  == opponent.getY())) {
    x++;
   }
   if (keyCode == keys[3] && moving.getY() < grid.getNumCols()-1 && !(moving.getY()+1 == opponent.getY() && moving.getX() == opponent.getX())) {
    y++;
   }
    handleCollisions(x,y,moving,opponent,keyCode);
    if (moving == player1){
      p1movedebounce = false;
    }
    if (moving == player2){
      p2movedebounce = false;
    }
}
//Method to handle the collisions between Sprites on the Screen
public void handleCollisions(int x, int y, Player moving, Player opponent, int direction){
    blocklist = grid.getBList();
    boolean move = true;
    GridLocation loc = new GridLocation(x, y);
    if (opponent.collisionCheck(loc) == true) {
      move = false;
    }

    Block b = blocklist[x][y];
      if (b != null && b.getType().equals("Raincoat")){
        moving.addLife();
        lifeSound.play();
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("Hose")){
        moving.raiseExplosionRadius();
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("SpareBalloon")){
        moving.raiseMaxBombs();
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("PiercingBalloon")){
        moving.piercePowerup();
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("HardHat")){
        moving.sdImmunePowerup();
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("BoxingGlove")){
        moving.glovePowerup();
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("Skates")){
        moving.skatePowerup();
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("RollerBlades")){
        moving.maxMoveSpeed();
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("Sponge")){
        moving.addLife();
        moving.addLife();
        moving.addLife();
        lifeSound.play();
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("WaterTank")){
        moving.setExplosionRadius(10);
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("Hydrogen")){
        moving.strongerBombs();
        blocklist[x][y] = null;
      }
      else if (b != null && b.getType().equals("PackOfBalloons")){
        moving.setMaxBombs(5);
        blocklist[x][y] = null;
      }
      else if ((b != null && b.getLocation().equals(loc)) || (blocklist[moving.getX()][moving.getY()] != null && blocklist[moving.getX()][moving.getY()].getType().equals("Explosion"))){
        move = false;
        if (moving.canPush() == true && b != null && b.getLocation().equals(loc) && b.getType().equals("Balloon")){
          Block movable = blocklist[x][y];
          int dirx = x - moving.getX();
          int diry = y - moving.getY();
          movable.pushBomb(dirx,diry);
          kicksound.play();
        }
      }
    //shift the player1 picture up in the 2D array
    if (move == true) {
      moving.resetMoveTimer();
      moving.setX(x);
      moving.setY(y);
      grid.setTileImage(loc,moving.getImage());
    }

}
public void placeBomb(Player placer){
    placeSound.play();
    placer.addBomb();
    PImage wall = loadImage("images/balloon.png");
    wall.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
    GridLocation loc = placer.getLocation();
    grid.setMark("B", loc);
    grid.setTileImage(loc, wall);
    Block b = new Block(wall,loc,"Balloon",placer);
    grid.addBlock(b);
    System.out.println(blocklist);
}
//method to indicate when the main game is over
public boolean isGameOver(){
  return !(player1.isLiving() && player2.isLiving()); //game ends when one player dies.
}

//method to describe what happens after the game is over
public void endGame(){
    //System.out.println("Game Over!");

    //Update the title bar

    //Show any end imagery
    //background(bg);


}

//example method that creates 5 horses along the screen
public void exampleAnimationSetup(){  
  int i = 2;
  exampleSprite = new AnimatedSprite("sprites/horse_run.png", 50.0f, i*75.0f, "sprites/horse_run.json");
}

//example method that animates the horse Sprites
public void checkExampleAnimation(){
  if(doAnimation){
    exampleSprite.animateVertical(5.0f, 0.1f, true);
  }
}
/* Animated Sprite class - useful to have Sprites move around
 * Designed to be used with Spritesheets & JSON Array files from TexturePacker software: 
 * https://free-tex-packer.com/app/
 * Inspired by Daniel Shiffman's p5js Animated Sprite tutorial: https://youtu.be/3noMeuufLZY
 * Author: Joel Bianchi, Aiden Sing, Tahlei Richardson
 * Last Edit: 5/31/2023
 * Edited jsonFile renamed to jsonFile
 * Variable to track animation speed
 */
 
public class AnimatedSprite extends Sprite{
  
    private String jsonFile;
    private ArrayList<PImage> animation;
    // private int w;
    // private int h;
    private int len;
    private float iBucket;
    private float aSpeed; //variable to track how quickly the animation images cycle

    JSONObject spriteData;
    PImage spriteSheet;

  // Constructor #1 for AnimatedSprite with Spritesheet (Must use the TexturePacker to make the JSON)
  // https://www.codeandweb.com/texturepacker
  public AnimatedSprite(String png, String json, float x, float y ) {
    super(png, x, y, 1.0f, true);
    
    this.jsonFile = json;
    this.animation = new ArrayList<PImage>();
 
    spriteData = loadJSONObject(json);
    spriteSheet = loadImage(png);
    JSONArray frames = spriteData.getJSONArray("frames");
    
    System.out.println("Loading Animated Sprite...");
    for(int i=0; i<frames.size(); i++){

      JSONObject frame = frames.getJSONObject(i);
      //System.out.println(i + ": " + frame + "\n");
      JSONObject fr = frame.getJSONObject("frame");
      //System.out.println("ss: " + fr + "\n");

      int sX = fr.getInt("x");
      int sY = fr.getInt("y");
      int sW = fr.getInt("w");
      int sH = fr.getInt("h");
      System.out.println(i + ":\t sX:" + sX + ":\t sY:" + sY + ":\t sW:" + sW + ":\t sH:" + sH);
      PImage img = spriteSheet.get(sX, sY, sW, sH);
      animation.add(img);

      // this.w = this.animation.get(0).width;
      // this.h = this.animation.get(0).height;
      this.len = this.animation.size();
      this.iBucket = 0.0f;
      this.aSpeed = 0.0f;
    }
    super.setW(this.animation.get(0).width);
    super.setH(this.animation.get(0).height);
    super.setLeft(x);
    super.setTop(y);
    //System.out.println("AS w: " + super.getW() + ",h: " + super.getH());

  }

  // Constructor #2 taking in images and json only
  public AnimatedSprite(String png, String json) {
    this(png, 0.0f, 0.0f, json);
  }

  // Legacy Constructor for 2022 version
    public AnimatedSprite(String png, float x, float y, String json) {
      this(png, json, x, y);
    }


  //Overriden method: Displays the correct frame of the Sprite image on the screen
  public void show() {
    int index = (int) Math.floor(Math.abs(this.iBucket)) % this.len;
    image(animation.get(index), super.getLeft(), super.getTop());
    //System.out.println("Pos: "+ super.getX() +"," + super.getY());
  } 

  //Method to cycle through the images of the animated sprite
  public void animate(float animationSpeed){
    iBucket +=  animationSpeed * aSpeed;
    show();
  }

  //Method that makes animated sprite move in any straight line
  public void animateMove(float hSpeed, float vSpeed, float animationSpeed, boolean wraparound){
    
    //adjust speed & frames
    animate(animationSpeed);
    super.move( (int) (hSpeed * 10), (int) (vSpeed * 10) );
  
    //wraparound sprite if goes off the right or left
    if(wraparound){
      wraparoundHorizontal();
      wraparoundVertical();
    }
  }

  //animated method that makes the Sprite move to the right-left
  public void animateHorizontal(float horizontalSpeed, float animationSpeed, boolean wraparound) {
    animateMove(horizontalSpeed, 0, animationSpeed, wraparound);
  }

  //animated method that makes the Sprite move down-up
  public void animateVertical(float verticalSpeed, float animationSpeed, boolean wraparound) {
    animateMove(0, verticalSpeed, animationSpeed, wraparound);
  }

  //Accessor method for the JSON path
  public String getJsonFile(){
    return this.jsonFile;
  }
  
  //Mutator method for the speed of the animation -Aiden Sing & Tahlei Richardson, 2023
  public void setAnimationSpeed(float aSpeed) {
    this.aSpeed = aSpeed;
  }
  

  //---------------------PRIVATE HELPER METHODS--------------------------//

  //wraparound sprite if goes off the right-left
  private void wraparoundHorizontal(){
    if ( super.getLeft() > width ) {
      super.setLeft( -super.getW() );
    } else if ( super.getRight() < -width ){
      super.setRight( width );
    }
  }

  //wraparound sprite if goes off the top-bottom
  private void wraparoundVertical(){
    if ( super.getTop() > height ) {
      super.setTop( -super.getH() );
    } else if ( super.getBottom() < -height ){
      super.setBottom( height );
    }
  }


}


public class Block {

    private GridLocation loc;
    private PImage Pi;
    private String type;
    private boolean alive;
    private Player owner;
    private int timer;
    private int pushTimer;
    private int dirx;
    private int diry;
    private boolean isPushed = false;
    private boolean canUpdate = true;
    public Block(PImage P){
        this(P,new GridLocation(0,0),"Wall",null);
    }
    public Block(PImage P, GridLocation l){
        this(P,l,"Wall", null);
    }
    public Block(PImage P, GridLocation l, String t){
        this(P,l,t,null);

    }
    public Block(PImage P, int x, int y){
        this(P,new GridLocation(x,y),"Wall",null);
    }
    public Block(PImage P, int x, int y, String t){
        this(P,new GridLocation(x,y),t,null);
    }
    public Block(PImage P, int x, int y, String t, Player o){
      this(P,new GridLocation(x,y),t,o);
    }
    public Block(PImage P, GridLocation l, String t, Player o){
        Pi = P;
        loc = l;
        type = t;
        owner = o;
        alive = true;
        if (type.equals("Balloon")){
           timer = 2000;
        } else if (type.equals("Explosion")) {
           timer = 300;
        }
    }
    public int getX(){
        return loc.getRow();
    }
    public int getY(){
        return loc.getCol();
    }
    public Player getOwner(){
        return owner;
    }
    public GridLocation getLocation(){
        return loc;
    }
    public PImage getImage(){
        return Pi;
    }
    public String getType(){
        return type;
    }
    public int getPushTimer(){
      return pushTimer;
    }
    public void Kill(){
        alive = false;
    }
    public boolean isAlive(){
        return alive;
    }
    public boolean isDestructible(){
        if (type.equals("Wall")) return true;
        return false;
    }
    public void updateLocation(GridLocation l){
      grid.updateBList(loc, l);
        loc = l;
        
    }
    public void updateLocation(int x,int y){
        grid.updateBList(loc, new GridLocation(x,y));
        loc = new GridLocation(x,y);
    }
    public void updateImage(PImage P){
        Pi = P;
    }
    public void resetPushTimer(){
      pushTimer = 150;
    }
    public boolean isAbleToUpdate(){
      return canUpdate;
    }
public void update(double dt){
  if (canUpdate == true){
    if (this == null || this.alive == false){
      Block[][] blocklist = grid.getBList();
      blocklist[this.getX()][this.getY()] = null;
      grid.removeMark(loc);
      canUpdate = false;
      return;
    }
    if (type.equals("Balloon")){
      timer-=dt;
        if (timer <= 0){
          this.Explode();
        }
            if (pushTimer > 0){
      pushTimer-=dt;
    }
    if (pushTimer <= 0){
      if (isPushed == true){
        pushBomb(dirx,diry);
      }
    }
    } else if (type.equals("Explosion")){
      timer-=dt;
      if (timer <= 0){
        Block[][] blocklist = grid.getBList();
        
        if (this.owner != null && Math.random() < .3f){
          String pow = this.getRandomPower();
          PImage powimage = loadImage("images/"+pow+".png");
          powimage.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
          if (pow.equals("balloon")){
            blocklist[this.getX()][this.getY()] = new Block(powimage,this.getLocation(),"Balloon");
          }
          else{
            blocklist[this.getX()][this.getY()] = new Block(powimage,this.getLocation(),pow);
          }
        } else {
          blocklist[this.getX()][this.getY()] = null;
        }
      }
    }
  }
}

public String getRandomPower(){
    int rnd = new Random().nextInt(powers.length);
    return powers[rnd];
}
  public void Explode(){
    this.Explode(false,false);
  }
    public void Explode(boolean p1cd, boolean p2cd){
              isPushed = false;
    PImage exp = loadImage("images/splash.png");
    exp.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
    Block[][] blocklist = grid.getBList();
    GridLocation loc = this.getLocation();
    boolean p1hit = false;
    boolean p2hit = false;
    if (this.isAlive() == false){
      return;
    }
    this.Kill();
    int radius;
    if (owner == null){
      radius = 1;
    } else {
      radius = owner.getExplosionRadius();
    }
    for (int[] dir : dirs){
      for(int i = 0; i <= radius; i++){
        int x = this.getX() + dir[0] * i;
        int y = this.getY() + dir[1] * i;
        if (x < 0 || x >= grid.getNumRows() || y < 0 || y >= grid.getNumCols()){
          continue;
        }
        Block cell = blocklist[x][y];
        //System.out.println(cell);
        if (cell == null)
        {
          blocklist[x][y] = new Block(exp,x,y,"Explosion");
                    GridLocation eloc = new GridLocation(x,y);
          if (eloc.equals(player1.getLocation()) && !(player1 == owner && player1.selfHarm() != true)){
            p1hit = true;
          }
          if (eloc.equals(player2.getLocation()) && !(player2 == owner && player2.selfHarm() != true)){
            p2hit = true;
          }
          continue;
          
        }
        
          if (cell.getType().equals("Fire")){
            blocklist[x][y] = new Block(exp,x,y,"Explosion", owner);
            if (owner != null && owner.canPierce() == true){
              continue;
            }
            break;
          }
          if (cell.getType().equals("Wall")){
            if (owner != null && owner.canPierce() == true){
              continue;
            }
            break;
          }

          GridLocation eloc = new GridLocation(x,y);
          if (eloc.equals(player1.getLocation()) && !(player1 == owner && player1.selfHarm() != true)){
            p1hit = true;
          }
          if (eloc.equals(player2.getLocation())  && !(player2 == owner && player2.selfHarm() != true)){
            p2hit = true;
          }
    if (p1hit == true && p1cd == false){
      if (owner != null && owner.areBombsStrong() == true && owner != player1){
        player1.hurtPlayer(2);
      }
      else{
        player1.hurtPlayer();
      }
      p1cd = true;
    }
    if (p2hit == true && p2cd == false){
      if (owner != null && owner.areBombsStrong() == true && owner != player2){
        player2.hurtPlayer(2);
      }
      else{
        player2.hurtPlayer();
      }
      p2cd = true;
    }
          if (cell.getType().equals("Balloon")){
            //System.out.println(cell.isAlive());
            if (cell.isAlive() == true){
              blocklist[x][y].Explode(p1hit,p2hit);
            }
          }

        
      }
    }
    boomSound.play();
    if (p1hit == true && p1cd == false){
      if (owner != null && owner.areBombsStrong() == true && owner != player1){
        player1.hurtPlayer(2);
      }
      else{
        player1.hurtPlayer();
      }
      p1cd = true;
    }
    if (p2hit == true && p2cd == false){
      if (owner != null && owner.areBombsStrong() == true && owner != player2){
        player2.hurtPlayer(2);
      }
      else{
        player2.hurtPlayer();
      }
      p2cd = true;
    }
    if (owner != null){
      owner.removeBomb();
    }
    blocklist[this.getX()][this.getY()] = new Block(exp,this.getX(),this.getY(),"Explosion");
    grid.removeMark(loc);
  }
  public void pushBomb(int dirx, int diry){
    Block[][] blocklist = grid.getBList();
    if (this == null || this.alive == false){
      blocklist[this.getX()][this.getY()] = null;
      grid.removeMark(loc);

      return;
    }
    this.resetPushTimer();
    this.dirx = dirx;
    this.diry = diry;
    int thisx = this.getX();
    int thisy = this.getY();

      int x = this.getX() + dirx;
      int y = this.getY() + diry;
      if (x < 0 || x >= grid.getNumRows() || y < 0 || y >= grid.getNumCols()){
        isPushed = false;
        return;
      }
      Block thisblock = blocklist[thisx][thisy];
      Block cell = blocklist[x][y];
      GridLocation eloc = new GridLocation(x,y);
        if (eloc.equals(player1.getLocation()) || eloc.equals(player2.getLocation())){
          this.Explode();
          isPushed = false;
          return;
        }
      if (cell != null && cell.getType().equals("Balloon")){
        this.Explode();
        isPushed = false;
        return;
      }
      if (cell != null && !cell.getType().equals("Explosion")){
        isPushed = false;
        return;
      }
      else {
        isPushed = true;
        this.updateLocation(x,y);
        if (cell != null && cell.getType().equals("Explosion")){
          this.Explode();
          isPushed = false;
          return;
        }
      }
      println("Running!");


  }
      public String toString(){
        if (owner != null){
            return "Game Object "+type+" with owner "+owner+" and a location of "+loc;
        }
        return "Game Object "+type+" with no owner and a location of "+loc;
    }
}
/* Grid Class - Used for rectangular-tiled games
 * A 2D array of GridTiles which can be marked
 * Author: Joel Bianchi
 * Last Edit: 5/24/2023
 * Edited to show all Images & Sprites
 */


public class Grid{
  private int rows;
  private int cols;
  private GridTile[][] board;
  private int lootTimer = 60000;
  private String[][] template = {
    {"x","x","","","","","","","","","","x","x"},
    {"x","▉","","▉","","▉","","▉","","▉","","▉","x"},
    {"","","","","","","","","","","","",""},
    {"","▉","","▉","","▉","","▉","","▉","","▉",""},
    {"","","","","","","","","","","","",""},
    {"","▉","","▉","","▉","","▉","","▉","","▉",""},
    {"","","","","","","","","","","","",""},
    {"","▉","","▉","","▉","","▉","","▉","","▉",""},
    {"","","","","","","","","","","","",""},
    {"x","▉","","▉","","▉","","▉","","▉","","▉","x"},
    {"x","x","","","","","","","","","","x","x"}
  };
  //Formula for map generation, with x giving an empty space and squares creating indestructible walls.
  private Block[][] blocklist;
  

  //Grid constructor that will create a Grid with the specified number of rows and cols
  public Grid(int rows, int cols){
    this.rows = rows;
    this.cols = cols;
    board = new GridTile[rows][cols];
    blocklist = new Block[rows][cols];
    
    for(int r=0; r<rows; r++){
      for(int c=0; c<cols; c++){
        board[r][c] = new GridTile(new GridLocation(r,c));
      }
    }
  }

  public void generateLevel()
  {
    PImage wall = loadImage("images/bricks.jpg");
    wall.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
    PImage fire = loadImage("images/fireblu.png");
    fire.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
    for (int x = 0; x < rows; x++){
      for (int y = 0; y < cols; y++){
        if (template[x][y].equals("") && Math.random() < .9f){

          blocklist[x][y] = new Block(fire,x,y,"Fire");
        }
        else if (template[x][y].equals("▉")){
          blocklist[x][y] = new Block(wall,x,y,"Wall");
        }
      }
    }
  }
  public void populateItems(){
    String[] items = new String[3];
    for (int i = 0; i < 3; i++){
      if (this.allFilled()){
        break;
      }
      int rndx = new Random().nextInt(rows);
      int rndy = new Random().nextInt(cols);
      String pow = this.getRandomPower();
      if (blocklist[rndx][rndy] != null || this.hasItem(items,pow)){
        i--;
        continue;
      }
      PImage powimage = loadImage("images/"+pow+".png");
      powimage.resize(this.getTileWidthPixels(),this.getTileHeightPixels()); 
      blocklist[rndx][rndy] = new Block(powimage,new GridLocation(rndx,rndy),pow);
      items[i] = pow;
    }
  }
  public String getRandomPower(){
    int rnd = new Random().nextInt(rarepowers.length);
    return rarepowers[rnd];
}

public boolean hasItem(String[] haystack, String needle){
  for (int i = 0; i < haystack.length; i++){
    if (haystack[i] != null && haystack[i].equals(needle)){
      return true;
    }
  }
  return false;
}
public boolean allFilled(){
  for (int r = 0; r < rows; r++){
    for (int c = 0; c < cols; c++){
      if (blocklist[r][c] == null){
        return false;
      }
    }
  }
  return true;
}

  public void addBlock(Block b){
    GridLocation loc = b.getLocation();
    int x = loc.getRow();
    int y = loc.getCol();
    blocklist[x][y] = b;
    //System.out.println(b);
    //System.out.println(blocklist[x][y]);
  }

  public void update(int dt){
    lootTimer-=dt;
    if (lootTimer <= 0){
      lootTimer = 30000;
      populateItems();
    }
    
  }

  
  // Default Grid constructor that creates a 3x3 Grid  
  public Grid(){
     this(3,3);
  }

  public Block[][] getBList(){
    return blocklist;
  }
  public void updateBList(GridLocation oldL, GridLocation newL){
    int oldx = oldL.getRow();
    int oldy = oldL.getCol();
    int newx = newL.getRow();
    int newy = newL.getCol();
    blocklist[newx][newy] = blocklist[oldx][oldy];
    blocklist[oldx][oldy] = null;
  }
  public void resetBList(){
    for (int r = 0; r < rows; r++){
      for (int c = 0; c < cols; c++){
        blocklist[r][c] = null;
      }
    }
  }
  // Method that Assigns a String mark to a location in the Grid.  
  // This mark is not necessarily visible, but can help in tracking
  // what you want recorded at each GridLocation.
  public void setMark(String mark, GridLocation loc){
    board[loc.getRow()][loc.getCol()].setNewMark(mark);
    //printGrid();
  } 
  public void resetLootTimer(){
    lootTimer = 60000;
  }
  // Method that Assigns a String mark to a location in the Grid.  
  // This mark is not necessarily visible, but can help in tracking
  // what you want recorded at each GridLocation.  
  // Returns true if mark is correctly set (no previous mark) or false if not
  public boolean setNewMark(String mark, GridLocation loc){
    int row = loc.getRow();
    int col = loc.getCol();
    boolean isGoodClick = board[row][col].setNewMark(mark);
    printGrid();
    return isGoodClick;
  }
  public String getMark(GridLocation loc){
    return board[loc.getRow()][loc.getCol()].getMark();
  }
  public boolean removeMark(GridLocation loc){
    boolean isGoodClick = board[loc.getRow()][loc.getCol()].removeMark();
    return isGoodClick;
  }
  public boolean hasMark(GridLocation loc){
    boolean isGoodClick = board[loc.getRow()][loc.getCol()].getMark() != " ";
    return isGoodClick;
  } 
  
  //Method that prints out the marks in the Grid to the console
  public void printGrid(){
   
    for(int r = 0; r<rows; r++){
      for(int c = 0; c<cols; c++){
         System.out.print(board[r][c]);
      }
      System.out.println();
    } 
  }
  
  //Method that returns the GridLocation of where the mouse is currently hovering over
  public GridLocation getGridLocation(){
      
    int row = mouseY/(pixelHeight/this.rows);
    int col = mouseX/(pixelWidth/this.cols);

    return new GridLocation(row, col);
  } 

  //Accessor method that provide the x-pixel value given a GridLocation loc
  public int getX(GridLocation loc){
    int widthOfOneTile = pixelWidth/this.cols;
    //calculate the left of the grid GridLocation
    int pixelX = (widthOfOneTile * loc.getCol()); 
    return pixelX;
  }
  public int getX(int row, int col){
    return getX(new GridLocation(row, col));
  }
  
  //Accessor method that provide the y-pixel value given a GridLocation loc
  public int getY(GridLocation loc){
    int heightOfOneTile = pixelHeight/this.rows;
    //calculate the top of the grid GridLocation
    int pixelY = (heightOfOneTile * loc.getRow()); 
    return pixelY;
  }
  public int getY(int row, int col){
    return getY(new GridLocation(row,col));
  }

  
  //Accessor method that returns the number of rows in the Grid
  public int getNumRows(){
    return rows;
  }
  
  //Accessor method that returns the number of cols in the Grid
  public int getNumCols(){
    return cols;
  }

  //Accessor method that returns the width of 1 Tile in the Grid
  public int getTileWidthPixels(){
    return pixelWidth/this.cols;
  }
  //Accessor method that returns the height of 1 Tile in the Grid
  public int getTileHeightPixels(){
    return pixelHeight/this.rows;
  }


  //Returns the GridTile object stored at a specified GridLocation
  public GridTile getTile(GridLocation loc){
    return board[loc.getRow()][loc.getCol()];
  }

  //Returns the GridTile object stored at a specified row and column
  public GridTile getTile(int r, int c){
    return board[r][c];
  }

  //------------------PImage Methods ---------------//
  //Method that sets the image at a particular tile in the grid & displays it
  public void setTileImage(GridLocation loc, PImage pi){
    GridTile tile = getTile(loc);
    tile.setImage(pi);
    showTileImage(loc);
  }

  //Method that returns the PImage associated with a particular Tile
  public PImage getTileImage(GridLocation loc){
    GridTile tile = getTile(loc);
    return tile.getImage();
  }


  //Method that returns if a Tile has a PImage
  public boolean hasTileImage(GridLocation loc){
    GridTile tile = getTile(loc);
    return tile.hasImage();
  }

  //Method that clears the tile image
  public void clearTileImage(GridLocation loc){
    setTileImage(loc,null);
  }

  public void showTileImage(GridLocation loc){
    GridTile tile = getTile(loc);
    if(tile.hasImage()){
      image(tile.getImage(),getX(loc),getY(loc));
    }
  }

  //Method to show all the PImages stored in each GridTile
  public void showImages(){

    //Loop through all the Tiles and display its images/sprites
      for(int r=0; r<getNumRows(); r++){
        for(int c=0; c<getNumCols(); c++){

          //Store temporary GridLocation
          GridLocation tempLoc = new GridLocation(r,c);
          
          //Check if the tile has an image
          if(hasTileImage(tempLoc)){
            showTileImage(tempLoc);
          }
        }
      }
  }

  //------------------AnimatedSprite Methods ---------------//
  //Method that sets the Sprite at a particular tile in the grid & displays it
  public void setTileSprite(GridLocation loc, AnimatedSprite sprite){
    GridTile tile = getTile(loc);
    if(sprite == null){
      tile.setSprite(null);
      //System.out.println("Cleared tile @ " + loc);
      return;
    }
    sprite.setLeft(getX(loc));
    sprite.setTop(getY(loc));
    tile.setSprite(sprite);
    showTileSprite(loc);
    //System.out.println("Succcessfully set tile @ " + loc);
  }
  
  //Method that returns the PImage associated with a particular Tile
  public AnimatedSprite getTileSprite(GridLocation loc){
    GridTile tile = getTile(loc);
    //System.out.println("Grid.getTileSprite() " + tile.getSprite());
    return tile.getSprite();
  }
  
  //Method that returns if a Tile has a PImage
  public boolean hasTileSprite(GridLocation loc){
    GridTile tile = getTile(loc);
    return tile.hasSprite();
  }

  //Method that clears the tile image
  public void clearTileSprite(GridLocation loc){
    setTileSprite(loc,null);
  }

  public void showTileSprite(GridLocation loc){
    GridTile tile = getTile(loc);
    if(tile.hasSprite()){
      tile.getSprite().animateMove(0.0f, 0.0f, 1.0f, true);
    }
  }

  
  //Method to show all the PImages stored in each GridTile
  public void showSprites(){

    //Loop through all the Tiles and display its images/sprites
      for(int r=0; r<getNumRows(); r++){
        for(int c=0; c<getNumCols(); c++){

          //Store temporary GridLocation
          GridLocation tempLoc = new GridLocation(r,c);
          
          //Check if the tile has an image
          if(hasTileSprite(tempLoc)){
            setTileSprite(tempLoc, getTileSprite(tempLoc));
            //showTileSprite(tempLoc);
          }
        }
      }
  }







  public void pause(final int milliseconds) {
    try {
      Thread.sleep(milliseconds);
    } catch (final Exception e) {
      // ignore
    }
  }


}
/* GridLocation class - helper class to store coordinates more easily
 * Author: Joel Bianchi
 * Last Edit: 5/22/2023
 * Added .equals() method, Renamed getRow() & getCol()
 */

public class GridLocation{
 
  int row;
  int col;
  
  public GridLocation(int row, int col){
    this.row = row;
    this.col = col;
  }
  
  public int getRow(){
    return row;
  }
  
  public int getCol(){
    return col;
  }
  
  public String toString(){
    return row + "," + col;
  }
  
  public int getYCoord() {
    return row;
  }
  
  public int getXCoord() {
    return col;
  }

  public boolean equals(GridLocation otherLoc){
    if(getRow() == otherLoc.getRow() && getCol() == otherLoc.getCol()){
      return true;
    }
    return false;

  }
 
}
/* GridTile class - Designed to be used within the Grid class
 * GridTiles have distinguishable marks that will be printed out to the console for easy visualization of a 2D array
 * GridTiles can indicate if they have been "captured", colored, or are displaying an image
 * Authors: Joel Bianchi, Naomi Gaylor, Ezzeldin Moussa
 * Last Edit: 5/23/2023
 * Edited to be superclass of HexTile, included hasImage() function
 */



public class GridTile{
  
  private GridLocation location;
  private PImage pi;
  private AnimatedSprite sprite;
  private boolean coveredPic;
  private int fillColor;
  final int defaultFillColor = 0xFFFFFFFF; //WHITE
  private int outlineColor;
  final int defaultOutlineColor = 0xFF000000; //BLACK
  private String mark;
  final private static String noMark = " ";
  private boolean isCaptured;

  //------------------GridTile Constructors ---------------//
  //GridTile constructor #1: Adds the specified String mark
  public GridTile(String mark, GridLocation loc){
    this.mark = mark;
    location = loc;
    fillColor = defaultFillColor;
    outlineColor = defaultOutlineColor;
    coveredPic = false;
  }
  
  //GridTile constructor #2 which adds a mark, but no Location
  public GridTile(String mark){
    this(mark, null);
  }

  //GridTile constructor #3 which adds a GridLocation, but no mark  
  public GridTile(GridLocation loc){
    this(noMark, loc);
  }

  //Default GridTile constructor which puts an empty String mark in the GridTile
  public GridTile(){
    this(noMark, null);
  }

  //------------------Marking Methods ---------------//
  // Accessor method that gets the mark in the GridTile
  public String getMark(){
    return mark;
  }
  
  // Mutator method that automatically changes the mark
  public void setMark(String mark){
    this.mark = mark;
  }

  // Mutator method sets a new mark in the GridTile 
  // if it does not already have a mark, 
  // returns true or false if successful
  public boolean setNewMark(String mark){
    if(this.mark.equals(noMark)){
      this.mark = mark;
      System.out.println("Successfully changed mark");
      return true;
    } else {
      System.out.println("That GridTile is already taken!");
      return false;
    }
  }

  public boolean removeMark(){
    if(this.mark.equals(noMark)){
      return false;
    }
    else{
      this.mark = noMark;
      return true;
    }
  }
  
  //------------------PImage Methods ---------------//
  // Mutator method that sets a new PImage in the GridTile
  public void setImage(PImage pi){
    this.pi = pi;
  }

  //Accessor method that returns the PImage stored in the GridTile
  public PImage getImage(){
    return pi;
  }

  //Method to check if the GridTile has an PImage in it
  public boolean hasImage(){
    if(pi == null){
      return false;
    }
    return true;
  }

  //------------------Sprite Methods ---------------//
 // Mutator method that sets a new AnimatedSprite in the GridTile
  public void setSprite(AnimatedSprite sprite){
    this.sprite = sprite;
  }

  //Accessor method that returns the AnimatedSprite stored in the GridTile
  public AnimatedSprite getSprite(){
    return sprite;
  }

  //Method to check if the GridTile has an AnimatedSprite in it
  public boolean hasSprite(){
    if(sprite == null){
      return false;
    }
    return true;
  }

  //------------------Capturing Tiles Methods ---------------//
  //method to "capture" a tile by changing its color
  public void captureTile(int clr){
    this.isCaptured = false;
    this.fillColor = clr;
  }

  //method to "release" a tile by changing its color
  public void releaseTile(){
    this.isCaptured = false;
    this.fillColor = defaultFillColor;
  }

  //accessor method to check if tile is captured
  public boolean checkIsCaptured(){
    return isCaptured;
  }


  //------------------Coloring Tiles Methods ---------------//
  //method to change the color of the tile
  public void setColor(int clr) {
    this.fillColor = clr;
  }

  //method to access the color of the tile
  public int getColor() {
    return fillColor;
  }

  public void setOutlineColor(int oclr){
    this.outlineColor = oclr;
  }

  public int getOutlineColor(){
    return this.outlineColor;
  }

  public void setCoveredWithPic(boolean isCoveredWithPic) {
    this.coveredPic = isCoveredWithPic;
  }

  public boolean isCoveredWithPic() {
    return this.coveredPic;
  }



  //method to access the location of the GridTile
  public GridLocation getLocation(){
      return location;
  }

  //ToString simply retuns the mark on the Tile, useful for printing out 2D grids
  public String toString(){
    return mark;
  }


}
/* HexGrid Class - useful for tile-based games with more flavor!
 * Inspired from CSRessel's Catan Game & Emmanuel Suriel's Grid class
 * https://github.com/CSRessel/catan/blob/master/src/gui/CatanBoard.java
 * Adapted for Processing
 * Authors: Joel Bianchi, Naomi Gaylor, Ezzeldin Moussa
 * Last Edit: 5/31/2023
 * NOT FULLY FUNCTIONAL YET
 */





public class HexGrid {

	ArrayList<HexLocation> allHexLocations;
	ArrayList<HexLocation> unclaimedLocations;
	
    private HexTile[][] map;
    private int defaultOutlineColor = 0xFFFFFFFF;	//WHITE
    private int defaultFillColor = 0xFF000000; 		//BLACK
	private int defaultBgColor = color(164,200,218);
	
	private boolean bgSet = false;

    //GUI fields
	private int hexGen;
	private int hexDiameter;
	private int boardHeight;
	private int hexagonSide;
	private int heightMargin = 100;
	private int widthMargin;
	private final double sqrt3div2 = 0.86602540378f;

    //HexGrid Constructor
    public HexGrid(int hexGen){

		this.hexGen = hexGen;

		//Generate all the valid hexLocations
		allHexLocations = new ArrayList<HexLocation>();
        
		hexDiameter = hexGen *2 -1;	//originally 5
		int midHex = hexGen;	//originally 3
		System.out.println("mid:" + midHex);

		//Create top half of HexLocations
		for(int r=1; r <= midHex; r++){
			for(int c=1; c <= midHex + r - 1; c++){
				allHexLocations.add( new HexLocation(c,r) );
			}
		}
		//Create bottom half of HexLocations
		for(int r = midHex +1; r <= hexDiameter; r++){
			for(int c= r-midHex + 1; c <= hexDiameter; c++){
				allHexLocations.add( new HexLocation(c,r) );
			}
		}
		
		System.out.println("All generated HexLocations:");
		System.out.println(allHexLocations);

		//Construct 2D array of HexTiles
		int row = hexDiameter + 2;
		int col = row;
        map = new HexTile[row][col];

		//Initialize unclaimed HexLocations arrayList
		unclaimedLocations = new ArrayList<HexLocation>();

		for(HexLocation loc: allHexLocations){

			//Generate hexTiles for each HexLocation
			HexTile hTile = new HexTile(loc, this.hexDiameter);
			map[loc.getYCoord()][loc.getXCoord()] = hTile;
			hTile.setColor(defaultFillColor);
			hTile.setOutlineColor(defaultOutlineColor);
			setHexTileCenterPixels(hTile);
			setHexTilePoly(hTile);

			//Generate unclaimedTiles ArrayList
			unclaimedLocations.add(loc);
		}
    }

	public boolean isValidLocation(HexLocation testLoc){
		for(int i=0; i<unclaimedLocations.size(); i++){
			if(unclaimedLocations.get(i).equals(testLoc)){
				return true;
			}
		}
		return false;
	}

	public boolean isWithinOne(HexLocation start, HexLocation end){
		int startX = start.getXCoord();
		int startY = start.getYCoord();
		int endX = end.getXCoord();
		int endY = end.getYCoord();

		if(endX==startX+1 || endX==startX-1 || endX==startX){
			if(endY==startY+1 || endY==startY-1 || endY==startY){
				return true;
			}
		}
		return false;
	}

	public boolean isWithinTwo(HexLocation start, HexLocation end){
		int startX = start.getXCoord();
		int startY = start.getYCoord();
		int endX = end.getXCoord();
		int endY = end.getYCoord();

		if(endX==startX+2 || endX==startX+1 || endX==startX-2 || endX==startX-1 || endX==startX){
			if(endY==startY+2 || endY==startY+1 || endY==startY-2 || endY==startY-1 || endY==startY){
				return true;
			}
		}
		return false;
	}

	public void removeHexLocation(HexLocation loc){
		for(int i=0; i<unclaimedLocations.size(); i++){
      		if(unclaimedLocations.get(i).equals(loc)){
        		unclaimedLocations.remove(i);
				return;
			}
		}
		System.out.println("Error when trying to remove Location: " + loc);
	}


	public void displayHexGrid(){

        int mapHeight = map.length;
        //int hexagonSide = 50;
		//int hexagonSide = (mapHeight - 2 * heightMargin) / 8;
        int widthMargin = (width - (int) (10 * hexagonSide * sqrt3div2)) / 2;

        // Graphics2D g2 = (Graphics2D)g;
        // g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        // g.setFont(new Font("TimesRoman", Font.PLAIN, 20));
        // super.paintComponent(g2);

		//System.out.println("ahl size: " + allHexLocations.size());

		//Fill in each Hex
		for(HexLocation loc: allHexLocations){
			int x = loc.getXCoord();
			int y = loc.getYCoord();
			HexTile hTile = map[x][y];
			//System.out.println(hTile);
			fillOneHex(hTile);
		}

		//Outline each Hex
		for(HexLocation loc: allHexLocations){
			int x = loc.getXCoord();
			int y = loc.getYCoord();
			HexTile hTile = map[x][y];
			outlineOneHex(hTile);
		}

		//System.out.println("HexLocations: " + hexLocations);
    }

	private void setHexTileCenterPixels(HexTile hTile){
		int x = hTile.getLocation().getXCoord();
        int y = hTile.getLocation().getYCoord();
		Point centerPixels = findTileCenter(hTile);
		hTile.setHexCenterPixels(centerPixels);
	}

	private void setHexTilePoly(HexTile hTile){
        Polygon hexPoly = makeHex(hTile.getCenterPixels());
		hTile.setHexPoly(hexPoly);
	}

	//method to fill in 1 hex tile
    public void fillOneHex(HexTile hTile){

        boolean hasImage = hTile.hasImage();
		//System.out.println("drawHex: x:"+tile.getLocation().getXCoord()+",y:"+tile.getLocation().getYCoord());
		
        //FILL IN SOLID COLOR - fill in hexTile with a solid color if no picture
        if(!hasImage){
			int fillClr = hTile.getColor();
			
			// ???

		}
    		
        //FILL IN PICTURE
        if(hasImage){    
			PImage photo = hTile.getImage();
			
			try{
				//resize the image to fit in the hex
				int iSize = (int) (hexagonSide * 1.25f);
				photo.resize(iSize, iSize);

				//mask the image to the hex shape
				PGraphics maskImage;
				maskImage = createGraphics(iSize,iSize);
				maskImage.beginDraw();
				//maskImage.triangle(30, 480, 256, 30, 480, 480);
				//maskImage = drawOneHex(PGraphics maskImage);
				maskImage.endDraw();
				
				// apply mask
				photo.mask(maskImage);

				//display masked image
				image(photo, 0, 0);

				final int ix = getImageX(hTile, photo);
				final int iy = getImageY(hTile, photo);
				
				//System.out.println("Img: " + locImageName);
				//System.out.println("nPoints:" + poly.npoints);
				//System.out.println("ix:" + ix + "\tiy:"+iy);

				//System.out.println("Drew image for x:" + x + ",y:" + y);

			} catch(Exception e){

			} //end catch
		} //end image fill
	} //end drawing one hex

	//method to draw the outline around a hex tile
    public void outlineOneHex(HexTile hTile){
		int oClr = hTile.defaultOutlineColor;
		float stroke = 3.0f;
		int tileOutlineColor = hTile.getOutlineColor();
		
		if(tileOutlineColor != oClr){
			PGraphics pg = getHexPGraphics(hTile);

			//DRAW THE OUTLINE!???

		}
	}


//---------------------- HELPER METHODS -------------------------------//
    private int getImageX(HexTile hTile, PImage image){
    	Point center = findTileCenter(hTile);
        int imageWidth =  image.width;
        return center.x - imageWidth/2; 
    }
    private int getImageY(HexTile hTile, PImage image){        
        Point center = findTileCenter(hTile);
        int imageHeight =  image.height;
        return center.y - imageHeight/2; 
    }

	//method finds the center pixels of a HexTile based on its grid coordinates
	private Point findTileCenter(HexTile hTile){
		return findTileCenter(hTile.getLocation().getXCoord(), hTile.getLocation().getYCoord());
	}
	private Point findTileCenter(int xcoord, int ycoord){
		int x = xcoord;
		int y = ycoord;
		//code for a bottom left origin with rows as x and cols as y
		// int xCenter = widthMargin + (int) (3 * hexagonSide * sqrt3div2)
		// 		+ (int) ((x - 1) * 2 * hexagonSide * sqrt3div2)
		// 		- (int) ((y - 1) * hexagonSide * sqrt3div2);
		// int yCenter = boardHeight - (heightMargin + hexagonSide
		// 		+ (int) ((y - 1) * hexagonSide * 1.5));

		//code for a top left origin (to mimic how Java 2D arrays are modeled) with rows as y and cols as x
		int xCenter = widthMargin + (int) (3 * hexagonSide * sqrt3div2)
		+ (int) ((x - 1) * 2 * hexagonSide * sqrt3div2)
		- (int) ((y - 1) * hexagonSide * sqrt3div2);
		
		int yCenter = (heightMargin + hexagonSide 
		+ (int) ((y - 1) * hexagonSide * 1.5f));

		return new Point(xCenter,yCenter);
	}



    //MUTATOR METHODS
    public void setAllTileColors(int tileColor){
        this.defaultFillColor = tileColor;
          for (int r = 0; r < map.length; r++) {
            for (int c = 0; c < map[0].length; c++) {
                if (map[r][c] != null){
                    map[r][c].setColor(defaultFillColor);
                }
            }
        }
    }

	public void setAllTileOutlines(int outlineColor){
        this.defaultFillColor = outlineColor;
          for (int r = 0; r < map.length; r++) {
            for (int c = 0; c < map[0].length; c++) {
                if (map[r][c] != null){
                    map[r][c].setOutlineColor(defaultFillColor);
                }
            }
        }


    }


	//method to access any Hextile based on its location
    public HexTile getHexTile(HexLocation loc){
		int x = loc.getXCoord();
		int y = loc.getYCoord();
        return map[x][y];
    }

    public int setTileColor(HexLocation loc, int tileColor){
		HexTile hTile = getHexTile(loc);
        int oldColor = hTile.getColor();
        hTile.setColor(tileColor);
        return oldColor;
    }

	public void highlightTile(HexLocation loc) {
		HexTile hTile = getHexTile(loc);
		int highlightColor = 0xFFFFFFFF;

		Point p = hTile.getCenterPixels();

		//Shape shape = new Ellipse2D.Double((int)p.getX() - 25, (int)p.getY() - 25, 50, 50);

		// g2.setColor(Color.WHITE);
		// g2.fill(shape);
		// g2.draw(shape);
	}
    


    /* ---------------  HEX GRID ACCESSOR METHODS ------------------ */
	public HexTile[][] getMap(){
        return map;
    }
    
    public int getNumRows() {
		return map.length;
	}

	public int getNumCols() {
		return map[0].length;
	}

    //needs to be modified slightly because HexGrid doesn't include ALL tiles in the rectangle (like 0,0)
	public boolean isValid(final HexLocation loc) {
		final int row = loc.getYCoord();
		final int col = loc.getXCoord();
		return 0 <= row && row < getNumRows() && 0 <= col && col < getNumCols();
	}


    /* ---------------- BACKGROUND IMAGE METHODS ------------------------- */



	/**
	 * sets the background to imgName. The img is resized to fit in the grids
	 * dimensions. setColor() is disabled
	 * 
	 * @param imgName
	 */
	public void setBackground(PImage bgImage) {
		// this.xOffset = 0;
		// this.yOffset = 0;
		// this.xScale = 1.0;
		// this.yScale = 1.0;

		// backgroundImage = loadImage(imgName);
		// bgSet = true;

		//repaint();
	}

	/**
	 * Removes a regular background or moveable background, allowing setColor to
	 * work again.
	 */
	public void removeBackground() {
		bgSet = false;
	}



	public void setFillColor(final HexLocation loc, final int clr) {
		if (!isValid(loc))
			throw new RuntimeException("cannot set color of invalid location " + loc + " to color " + clr);
		map[loc.getXCoord()][loc.getYCoord()].setColor(clr);
		//repaint();
	}

	public int getFillColor(final HexLocation loc) {
		if (!isValid(loc))
			throw new RuntimeException("cannot get color from invalid location " + loc);
		return map[loc.getYCoord()][loc.getXCoord()].getColor();
	}

	// public void setImage(final HexLocation loc, final String imageFileName) {
	// 	if (!isValid(loc))
	// 		throw new RuntimeException(
	// 				"cannot set image for invalid location " + loc + " to \"" + imageFileName + "\"");
	// 	map[loc.getXCoord()][loc.getYCoord()].setImageFileName(imageFileName);
	// 	repaint();
	// }

	// public String getImage(final Location loc) {
	// 	if (!isValid(loc))
	// 		throw new RuntimeException("cannot get image for invalid location " + loc);
	// 	return map[loc.getYCoord()][loc.getXCoord()].getImageFileName();
	// }

	public void setTileOutlineColor(final HexLocation loc, final int oclr) {
		if (!isValid(loc))
			throw new RuntimeException("cannot set outline for invalid location " + loc);
            map[loc.getXCoord()][loc.getYCoord()].setOutlineColor(oclr);
		//repaint();
	}

	public int getTileOutlineColor(final HexLocation loc) {
		if (!isValid(loc))
			throw new RuntimeException("cannot get outline color for invalid location " + loc);
		return map[loc.getXCoord()][loc.getYCoord()].getOutlineColor();
	}

	public void setAllOutlinesColor(final int oclr) {
		for (int r = 0; r < getNumRows(); r++) {
			for (int c = 0; c < getNumCols(); c++) {
				map[r][c].setOutlineColor(oclr);
			}
		}
		//repaint();
	}



    /* ----- INPUT HANDLING -------------------------------------------------------------------- */
	// // returns -1 if no key pressed since last call.
	// // otherwise returns the code for the last key pressed.
	// public int checkLastKeyPressed() {
	// 	final int key = lastKeyPressed;
	// 	lastKeyPressed = -1;
	// 	return key;
	// }

	// // returns null if no location clicked since last call.
	// public HexLocation checkLastLocationClicked() {
	// 	final HexLocation loc = lastLocationClicked;
	// 	lastLocationClicked = null;
	// 	return loc;
	// }

	// public HexLocation waitForClick() {
	// 	while (true) {
	// 		final HexLocation clicked = this.checkLastLocationClicked();
	// 		if (clicked != null) {
	// 			//System.out.print("x:"+clicked.getXCoord()+ ",y:" + clicked.getYCoord());
	// 			return clicked;
	// 		} else {
	// 			//System.out.print("NOT CLICKED");
	// 			HexGrid.pause(100);
	// 		}
	// 	}
	// }

    // public static void pause(final int milliseconds) {
	// 	try {
	// 		Thread.sleep(milliseconds);
	// 	} catch (final Exception e) {
	// 		// ignore
	// 	}
	// }

    // public void keyPressed(final KeyEvent e) {
	// 	lastKeyPressed = e.getKeyCode();
	// }

	// public void mousePressed(final MouseEvent e) {

	// 	Point p = e.getPoint();
	// 	//System.out.println(p);
		
	// 	for(HexLocation loc : this.allHexLocations){
	// 		HexTile hTile = map[loc.getXCoord()][loc.getYCoord()];
	// 		Polygon hexPoly = hTile.getHexPoly();
	// 		if(hexPoly.contains(p)){
				
	// 			lastLocationClicked = loc;
				
	// 		}
	// 	}
	// }



    // ------------------ GUI HELPER METHODS --------------------------------------------------------------------------//

    // private void guiInit() {
    //     lastKeyPressed = -1;
    //     lastLocationClicked = null;

    //     frame = new JFrame("Grid");
    //     frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	// 	fullscreen();	//makes the it stay on the left??
    //     frame.addKeyListener(this);

    //     int mapSize = Math.max(Math.min(500 / getNumRows(), 500 / getNumCols()), 1);
    //     setPreferredSize(new Dimension(mapSize * getNumCols(), mapSize * getNumRows()));
    //     addMouseListener(this);
    //     frame.getContentPane().add(this);

    //     frame.pack();
    //     frame.setVisible(true);

	// 	setBackground(defaultBgColor); //TODO add background

	// 	boardHeight = getHeight();
	// 	hexagonSide = 250 / (hexGen + 2);
	// 	//hexagonSide = 25;
	// 	//hexagonSide = (boardHeight - 2 * heightMargin) / 8;
	// 	widthMargin = (getWidth() - (int) (10 * hexagonSide * sqrt3div2)) / 2;
	// 	System.out.println("Boardheight: " + boardHeight);
	// 	System.out.println("HexagonSide: " + hexagonSide);
	// 	System.out.println("WidthMargin: " + widthMargin);

	// 	this.addComponentListener(new ComponentListener() {

    // 		public void componentResized(ComponentEvent e) {
    // 		//	System.out.println(e.getComponent().getSize());
    // 			boardHeight = getHeight();
    // 			//hexagonSide = (boardHeight - 2 * heightMargin) / 8;
    // 			widthMargin = (getWidth() - (int) (10 * hexagonSide * sqrt3div2)) / 2;
    // 			//System.out.println("Boardheight: " + boardHeight);
    // 			//System.out.println("HexagonSide: " + hexagonSide);
    // 			//System.out.println("WidthMargin: " + widthMargin);
    // 		}

    // 		public void componentHidden(ComponentEvent e) {}

    // 		public void componentMoved(ComponentEvent e) {}

    // 		public void componentShown(ComponentEvent e) {}
    // 	});

    // }

    // private void load(String imageFileName) {
    //     showFullImage(loadImage(imageFileName));
    //     setTitle(imageFileName);
    // }

    // private void save(String imageFileName) {
    //     try {
    //         BufferedImage bi = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);
    //         paintComponent(bi.getGraphics());
    //         int index = imageFileName.lastIndexOf('.');
    //         if (index == -1)
    //             throw new RuntimeException("invalid image file name:  " + imageFileName);
    //         ImageIO.write(bi, imageFileName.substring(index + 1), new File(imageFileName));
    //     } catch ( IOException e) {
    //         throw new RuntimeException("unable to save image to file:  " + imageFileName);
    //     }
    // }

	// private BufferedImage loadImage(String imageFileName) {
		
	// 	if(imageFileName == null || "".equals(imageFileName)){
	// 		System.out.println("Image is null or \"\"");
	// 		return null;
	// 	} else{
	// 		final URL url = getClass().getResource(imageFileName);
	// 		if (url == null) {
	// 			throw new RuntimeException("cannot find file:  " + imageFileName);
	// 		}
	// 		try {
	// 			return ImageIO.read(url);
	// 		} catch (IOException e) {
	// 			throw new RuntimeException("unable to read from file:  " + imageFileName);
	// 		}
	// 	}
	// }


    // private void showFullImage(BufferedImage image) {
    //     for (int row = 0; row < getNumRows(); row++) {
    //         for (int col = 0; col < getNumCols(); col++) {
    //             int x = col * image.getWidth() / getNumCols();
    //             int y = row * image.getHeight() / getNumRows();
    //             int c = image.getRGB(x, y);

    //             int red = (c & 0x00ff0000) >> 16;
    //             int green = (c & 0x0000ff00) >> 8;
    //             int blue = c & 0x000000ff;

    //             map[row][col].setColor(new Color(red, green, blue));
    //         }
    //     }
    //     repaint();
    // }

  

	// private displayHexTile(){
	// 	pushMatrix();
	// 	translate(width*0.8, height*0.5);
	// 	polygon(0, 0, 70, 6);
	// 	popMatrix();
	// }

	//function that creates a n-sided polygon on a point circle
	private void hexagon(HexTile hTile) {
		int npoints = 6;
		float x = hTile.getCenterPixels().x;
		float y = hTile.getCenterPixels().y;
		float angle = TWO_PI / npoints;
		float radius = hTile.getRadius();
		beginShape();
		for (float a = 0; a < TWO_PI; a += angle) {
			float sx = x + cos(a) * radius;
			float sy = y + sin(a) * radius;
			vertex(sx, sy);
		}
		endShape(CLOSE);
	}



	public Polygon makeHex(Point center) {
		int xCenter = (int) center.getX();
		int yCenter = (int) center.getY();

		Polygon output = new Polygon();
		output.addPoint(xCenter + 1, yCenter + hexagonSide + 1);
		output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter + (int) (.5f * hexagonSide) + 1);
		output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter - (int) (.5f * hexagonSide) - 1);
		output.addPoint(xCenter + 1, yCenter - hexagonSide - 1);
		output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter - (int) (.5f * hexagonSide) - 1);
		output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter + (int) (.5f * hexagonSide) + 1);

		return output;
	}

	public PGraphics getHexPGraphics(HexTile hTile) {

		Point centerPixels = hTile.getCenterPixels();
		int xCenter = (int) centerPixels.getX();
		int yCenter = (int) centerPixels.getY();

		PGraphics pg = new PGraphics();

		// Polygon output = new Polygon();
		// output.addPoint(xCenter + 1, yCenter + hexagonSide + 1);
		// output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter + (int) (.5 * hexagonSide) + 1);
		// output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter - (int) (.5 * hexagonSide) - 1);
		// output.addPoint(xCenter + 1, yCenter - hexagonSide - 1);
		// output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter - (int) (.5 * hexagonSide) - 1);
		// output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter + (int) (.5 * hexagonSide) + 1);

		return pg;
	}

}  
/* HexLocation Class
 * HexLocations use x & y coordinate instead of row & column designations
 * Author: Joel Bianchi
 * Last Edit: 5/16/2023
 */

public class HexLocation extends GridLocation{
 
  private int xCoord;
  private int yCoord;
  
  public HexLocation(int x, int y) {
    super(x,y);
    xCoord = x;
    yCoord = y;
  }
  
  public int getYCoord() {
    return yCoord;
  }
  
  public int getXCoord() {
    return xCoord;
  }
  
  public boolean equals(HexLocation otherLoc) {
    return yCoord == otherLoc.getYCoord() && xCoord == otherLoc.getXCoord();
  }
  
  public String toString() {
    return "(" + xCoord + ", " + yCoord + ")";
  }


}
/* HexTile Class
 * Based off code from Naomi Gaylor & Ezzeldin Moussa, June 2022
 * Last edit: 5/16/2023
 * Edited to be a subclass of GridTile pde file
 */




public class HexTile extends GridTile{
  
  private Polygon hexPoly;
  private float radius;
  private Point centerPixels;
  //private HexLocation hexLoc;

  //HexTile Constructor #1: GridLocation
  public HexTile(HexLocation loc, float rad){
    super(loc);
    //this.hexLoc = loc;
    this.radius = rad;
    this.centerPixels = new Point(0,0);
    this.hexPoly = null;
  }

  //HexTile Constructor #2: X,Y coordinates
  public HexTile(int xCord, int yCord, float rad){
    this(new HexLocation(xCord,yCord), rad);
  }

  //method to access the location of the GridTile
  // public HexLocation getLocation(){
  //     return location;
  // }

  //mutator method to define the center point of the Tile
  public void setHexCenterPixels(Point centerPixels){
    this.centerPixels = centerPixels;
  }
  //accessor method to the center point of the Tile
  public Point getCenterPixels(){
    return centerPixels;
  }

  //mutator method to change the Java Polygon object that defines the shape of the HexTile
  public void setHexPoly(Polygon hexPoly){
    this.hexPoly = hexPoly;
  }
  //accessor method to return the Java Polygon object
  public Polygon getPoly(){
    return hexPoly;
  }

  //accessor method to return the hexagon's radius
  public float getRadius(){
    return radius;
  }

    
}  
/* Platform class
 * Stub constructors provided
 * Can be used with the following tutorials:
 * https://longbaonguyen.github.io/courses/platformer/platformer.html
 * Authors: __________________
 * Last Edit: 5/17/2023
 */

public class Platform {//extends Sprite {

	//Platform defined by it's center-x and top-Y positions
	public Platform(float posXCenter, float posYTop, float platWidth, float platHeight, int clr) {

		//pass along the center-x and center-y to Sprite super
		//super(posXCenter, posYTop + (platHeight/2), clr);
		//System.out.println("PlatTopY: " + posYTop + "\tPlatCenterY: " + (posYTop + (platHeight/2)));
		// setWidth(platWidth);
		// setHeight(platHeight);
		//setColor(Color.black);
	}

	public Platform(float posXCenter, float posYTop, float platWidth, float platHeight) {
		//pass along the center-x and center-y to Sprite super
		this(posXCenter, posYTop, platWidth, platHeight, color(0,0,0));
	}

}
public class Player{    //Consider having Player extend from AnimatedSprite

    //position on x and y axis
    private int posx;
    private int posy;

    //Image of player
    private PImage Pi;

    //Player Stats from Powerups
    private int currentbombs = 0;
    private int maxbombs = 1;
    private int explosionradius = 1;
    private int lives = 1;
    private int skates = 0;
    private boolean bombpierce = false;
    private boolean selfdamage = true;
    private boolean bombpush = false;
    private boolean strongbombs = false;


    //Player Status
    private boolean isAlive;
    private long iframetimer = 0;
    private long movetimer = 0;
    private long maxmovetimer = 200;

    public Player(PImage P){
        this(P,0,0);
    }
    public Player(PImage P, int x, int y){
        this.Pi = P;
        this.posx = x;
        this.posy = y;
        this.isAlive = true;
    }
    public PImage getImage(){
        return Pi;
    }
    public int getX(){
        return posx;
    }
    public int getY(){
        return posy;
    }
    public int getMaxBombs(){
        return maxbombs;
    }
    public int getExplosionRadius(){
        return explosionradius;
    }
    public int getBombs(){
        return currentbombs;
    }
    public long getMoveTimer(){
        return movetimer;
    }
    public boolean isLiving(){
        return isAlive;
    }
    public boolean canPierce(){
        return bombpierce;
    }
    public boolean selfHarm(){
        return selfdamage;
    }
    public boolean canPush(){
        return bombpush;
    }
    public boolean areBombsStrong(){
        return strongbombs;
    }
    public GridLocation getLocation(){
        return new GridLocation(posx,posy);
    }
    public long getMaxMoveTimer(){
        return maxmovetimer;
    }
    public void hurtPlayer(){
        if (iframetimer <= 0){
            iframetimer = 200;
            lives--;
            System.out.println("Ouch!");
            if (lives <= 0){
                isAlive = false;
            }
        }
    }
    public void hurtPlayer(int l){
        if (iframetimer <= 0){
            iframetimer = 200;
            lives-=l;
            System.out.println("Yeowch!");
            if (lives <= 0){
                isAlive = false;
            }
        }
    }
    public void updateLocation(GridLocation l){
        posx = l.getRow();
        posy = l.getCol();
    }
    public void setName(){
        
    }
    public void setImage(PImage P){
        Pi = P;
    }
    public void maxMoveSpeed(){
       skates = 9;
       maxmovetimer = 200 - (20*skates);
    }
    public void skatePowerup(){
        skates = Math.min(skates+1,9);
        maxmovetimer = 200 - (20*skates);
    }
    public void setBombs(int b){
        currentbombs = b;
    }
    public void piercePowerup(){
        bombpierce = true;
    }
    public void sdImmunePowerup(){
        selfdamage = false;
    }
    public void strongerBombs(){
        strongbombs = true;
    }
    public void glovePowerup(){
        bombpush = true;
    }
    public void addBomb(){
        currentbombs++;
    }
    public void removeBomb(){
        currentbombs--;
    }
    public void addLife(){
        lives = Math.min(lives+1, 5);
    }
    public void setMaxBombs(int b){
        maxbombs = Math.min(b,5);
    }
    public void raiseMaxBombs(){
        maxbombs = Math.min(maxbombs+1,5);
    }
    public void resetMoveTimer(){
        movetimer = maxmovetimer;
    }
    public void lowerMaxBombs(){
        maxbombs--;
    }
    public void setExplosionRadius(int v){
        explosionradius = Math.min(v,10);
    }
    public void raiseExplosionRadius(){
        explosionradius = Math.min(explosionradius+1,10);
    }
    public void lowerExplosionRadius(){
        explosionradius--;
    }
    public void setX(int x){
        posx = x;
    }
    public void setY(int y){
        posy = y;
    }
    public void lowerX(){
        posx--;
    }
    public void lowerY(){
        posy--;
    }
    public void raiseX(){
        posx++;
    }
    public void raiseY(){
        posy++;
    }
    public void update(int dt){
        if (iframetimer > 0){
            iframetimer-=dt;
        }
        if (movetimer > 0){
            movetimer-=dt;
        }
    }
    public boolean collisionCheck(GridLocation loc){
        if (new GridLocation(posx,posy) == loc)
        {
            return true;
        }
        return false;
    }
}
/* Sprite class - to create objects that move around with their own properties
 * Inspired by Daniel Shiffman's p5js Animated Sprite tutorial
 * Author: Joel Bianchi
 * Last Edit: 5/31/22
 * Modified to account for picture coordinates at Top, Left corner
 * Added Constructor #3
 * spriteImgPath renamed to spriteImgFile
 */

public class Sprite {
  
    PImage spriteImg;
    private String spriteImgFile;
    private float center_x;
    private float center_y;
    private float speed_x;
    private float speed_y;
    private float w;
    private float h;
    private boolean isAnimated;


  // Main Constructor
  public Sprite(String spriteImgFile, float scale, float x, float y, boolean isAnimated) {
    this.spriteImgFile = spriteImgFile;
    setLeft(x);
    setTop(y);
    this.speed_x = 0;
    this.speed_y = 0;
    this.isAnimated = isAnimated;
    if(!isAnimated){
      this.spriteImg = loadImage(spriteImgFile);
      w = spriteImg.width * scale;
      h = spriteImg.height * scale;
    }

  }

  // Simpler Constructor for Non-Animated Sprite
  public Sprite(String spriteImgFile, float x, float y) {
    this(spriteImgFile, 1.0f, x, y, false);
  }

  //Constructor #3: Only pass in the image
  public Sprite(String spriteImgFile){
    this(spriteImgFile, 0.0f, 0.0f);
  }


  // method to display the Sprite image on the screen
  public void show() {
      image(spriteImg, getLeft(), getTop(), w, h);
  }

  // method to move Sprite image on the screen to a specific coordinate
  public void moveTo(float x, float y){
    setLeft(x);
    setTop(y);
  }

  // method to move Sprite image on the screen relative to current position
  public void move(float change_x, float change_y){
    this.center_x += change_x;
    this.center_y += change_y;
    //System.out.println(getLeft() + "," + getTop());
  }

  // method that automatically moves the Sprite based on its velocity
  public void update(){
    move(speed_x, speed_y);
  }


  // method to rotate Sprite image on the screen
  public void rotate(float degrees){

  }


  /*-- ACCESSOR METHODS --*/

  public float getW(){
    return w;
  }
  public float getH(){
    return h;
  }
  public float getCenterX(){
    return center_x;
  }
  public float getCenterY(){
    return center_y;
  }
  public PImage getImg(){
    return spriteImg;
  }
  public boolean getIsAnimated(){
    return isAnimated;
  }
  
  
  /*-- MUTATOR METHODS --*/
  public void setW(float w){
    this.w = w;
  }
  public void setH(float h){
    this.h=h;
  }
  public void setCenterX(float center_x){
    this.center_x = center_x;
  }
  public void setCenterY(float center_y){
    this.center_y=center_y;
  }
  public void setImg(PImage img){
    this.spriteImg = img;
  }
  public void setIsAnimated(boolean a){
    isAnimated = a;
  }


  /*-- SPRITE BOUNDARY METHODS --
    -- Used from Long Bao Nguyen
    -- https://longbaonguyen.github.io/courses/platformer/platformer.html
  */
   public void setLeft(float left){
    center_x = left + w/2;
  }
   public float getLeft(){
    return center_x - w/2;
  }
   public void setRight(float right){
    center_x = right - w/2;
  }
   public float getRight(){
    return center_x + w/2;
  }
   public void setTop(float top){
    center_y = top + h/2;
  }
   public float getTop(){
    return center_y - h/2;
  }
   public void setBottom(float bottom){
    center_y = bottom - h/2;
  }
   public float getBottom(){
    return center_y + h/2;
  }
  

  //Accessor method to the image path of the Sprite
  public String getImagePath(){
    return this.spriteImgFile;
  }
  
  //Accessor method to the image path of the Sprite
  public PImage getImage(){
    return this.spriteImg;
  }


  // //Method to check if 2 Sprites are the same (based on String)
  // public boolean equals(Sprite otherSprite){
  //   if(this.spriteImgFile.equals(otherSprite.getImagePath())){
  //     return true;
  //   }
  //   return false;
  // }

  //Method to check if 2 Sprites are the same (based on PImage)
  public boolean equals(Sprite otherSprite){
    if(this.spriteImgFile != null && otherSprite != null && this.spriteImgFile.equals(otherSprite.getImagePath())){
      return true;
    }
    return false;
  }

  public String toString(){
    return spriteImgFile + "\t" + getLeft() + "\t" + getTop() + "\t" + speed_x + "\t" + speed_y + "\t" + w + "\t" + h + "\t" + isAnimated;
  }

}


  public void settings() { size(800, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Game" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
