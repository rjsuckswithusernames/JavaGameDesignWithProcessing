/* autogenerated by Processing revision 1292 on 2023-05-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.Color;
import java.awt.Polygon;
import java.awt.Point;
import java.util.ArrayList;
import java.awt.Polygon;
import java.awt.Point;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Game extends PApplet {

/* Game Class Starter File
 * Last Edit: 12/13/2022
 * Authors: Raymond Morel, Muhammad Zahid
 */


//import processing.sound.*;

//GAME VARIABLES
private int msElapsed = 0;

int maximumx = 8;
int maximumy = 8;
Grid grid = new Grid(maximumx,maximumy);
PImage bg;

boolean secret = false;
boolean debounce = false;
Player player1;
Player player2;
PImage endScreen;
String titleText = "Puzzle game";
String extraText = "real";
AnimatedSprite exampleSprite;
boolean doAnimation;
ArrayList<Block> blocklist = new ArrayList<Block>();
ArrayList<Block> blocklist2 = new ArrayList<Block>();
//INPUTS

//P1
int wkey = 87;
int akey = 65;
int skey = 83;
int dkey = 68;
int ekey = 69;

//P2
int up = 38;
int left = 37;
int down = 40;
int right = 39;
int space = 32;

//SoundFile song;



//Required Processing method that gets run once
public void setup() {

  //Match the screen size to the background image size
  /* size commented out by preprocessor */;
  //Set the title on the title bar
  surface.setTitle(titleText);

  //Load images used
  //bg = loadImage("images/chess.jpg");
  bg = loadImage("images/werksugvfuywegg.jpg");
  bg.resize(800,600);

  PImage p1image = loadImage("images/x_wood.png");
  p1image.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
  PImage p2image = loadImage("images/spook.png");
  p2image.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
  player1 = new Player(p1image);
  player2 = new Player(p2image,maximumx-1,maximumy-1);
  endScreen = loadImage("images/youwin.png");

  // Load a soundfile from the /data folder of the sketch and play it back
  // song = new SoundFile(this, "sounds/Lenny_Kravitz_Fly_Away.mp3");
  // song.play();

  
  //Animation & Sprite setup
  exampleAnimationSetup();

  imageMode(CORNER);    //Set Images to read coordinates at corners
  //fullScreen();   //only use if not using a specfic bg image
  
  println("Game started...");

}

//Required Processing method that automatically loops
//(Anything drawn on the screen should be called from here)
public void draw() {


  updateTitleBar();

  if (msElapsed % 300 == 0) {
    populateSprites();
    moveSprites();
  }

  updateScreen();
  
  if(isGameOver()){
    endGame();
  }

  checkExampleAnimation();
  
  msElapsed +=(1/60);
  grid.pause(1/60);

}

//Known Processing method that automatically will run whenever a key is pressed
public void keyPressed(){

  //check what key was pressed
  System.out.println("Key pressed: " + keyCode); //keyCode gives you an integer for the key

  //What to do when a key is pressed?
  
  //player 1 movement
  if(keyCode == wkey || keyCode == akey || keyCode == skey || keyCode == dkey){
    //check case where out of bounds
    //change the field for player1Row
    int x = player1.getX();
    int y = player1.getY();
   if (keyCode == wkey && player1.getX() > 0 && !(player1.getX()-1 == player2.getX() && player1.getY()  == player2.getY()) ){
    x--;
   }
   if (keyCode == akey && player1.getY()  > 0 && !(player1.getY()-1 == player2.getY() && player1.getX() == player2.getX())) {
    y--;
   }
   if (keyCode == skey && player1.getX() < grid.getNumRows()-1 && !(player1.getX()+1 == player2.getX() && player1.getY()  == player2.getY())) {
    x++;
   }
   if (keyCode == dkey && player1.getY() < grid.getNumCols()-1 && !(player1.getY()+1 == player2.getY() && player1.getX() == player2.getX())) {
    y++;
   }
    System.out.println(x);
    System.out.println(y);
    boolean move = true;
    GridLocation loc = new GridLocation(x, y);
    if (player2.collisionCheck(loc) == true) {
      move = false;
    }
    for (int i = 0; i < blocklist.size(); i++){
      Block b = blocklist.get(i);
      System.out.println(b.getLocation());
      if (b.getLocation().equals(loc)){
        move = false;
      }
    }
    for (int i = 0; i < blocklist2.size(); i++){
      Block b = blocklist2.get(i);
      System.out.println(b.getLocation());
      if (b.getLocation().equals(loc)){
        move = false;
      }
    }
    //shift the player1 picture up in the 2D array
    if (move == true) {
      player1.setX(x);
      player1.setY(y);
      grid.setTileImage(loc,player1.getImage());
    }
    

    
    //eliminate the picture from the old location

  } //end player1movement
  if (keyCode == ekey && !(grid.hasMark(player1.getLocation()) == true)) {
    PImage wall = loadImage("images/bricks.jpg");
    wall.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
    GridLocation loc = player1.getLocation();
    grid.setMark("B", loc);
    grid.setTileImage(loc, wall);
    blocklist.add(new Block(wall,loc));
    if (blocklist.size() > 3){
      Block b = blocklist.get(0);
      grid.removeMark(b.getLocation());
      blocklist.remove(b);
    }
    System.out.println("Mark Placed");
  }
  //Player2 movement

  if(keyCode == up || keyCode == left || keyCode == down || keyCode == right){
    int x = player2.getX();
    int y = player2.getY();
   if (keyCode == up && player2.getX() > 0 && !(player2.getX()-1 == player1.getX() && player1.getY()  == player2.getY()) ){
    x--;
   }
   if (keyCode == left && player2.getY()  > 0 && !(player2.getY()-1 == player1.getY() && player1.getX() == player2.getX())) {
    y--;
   }
   if (keyCode == down && player2.getX() < grid.getNumRows()-1 && !(player2.getX()+1 == player1.getX() && player1.getY()  == player2.getY())) {
    x++;
   }
   if (keyCode == right && player2.getY() < grid.getNumCols()-1 && !(player2.getY()+1 == player1.getY() && player1.getX() == player2.getX())) {
    y++;
   }
    System.out.println(x);
    System.out.println(y);
    boolean move = true;
    GridLocation loc = new GridLocation(x, y);
    if (player1.collisionCheck(loc) == true) {
      move = false;
    }
    for (int i = 0; i < blocklist.size(); i++){
      Block b = blocklist.get(i);
      System.out.println(b.getLocation());
      if (b.getLocation().equals(loc)){
        move = false;
      }
    }
    for (int i = 0; i < blocklist2.size(); i++){
      Block b = blocklist2.get(i);
      System.out.println(b.getLocation());
      if (b.getLocation().equals(loc)){
        move = false;
      }
    }
      if (move == true) {
      player2.setX(x);
      player2.setY(y);
      grid.setTileImage(loc,player2.getImage());
    }
  } //end Player2movement
     if (keyCode == space && !(grid.hasMark(player2.getLocation()) == true)) {
    PImage wall = loadImage("images/fireblu.png ");
    wall.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
    GridLocation loc = player2.getLocation();
    grid.setMark("B", loc);
    grid.setTileImage(loc, wall);
    blocklist2.add(new Block(wall,loc));
    if (blocklist2.size() > 3){
      Block b = blocklist2.get(0);
      grid.removeMark(b.getLocation());
      blocklist2.remove(b);
    }
    System.out.println("Mark Placed");
  } 

  }


  //Known Processing method that automatically will run when a mouse click triggers it
  public void mouseClicked(){
  
    //check if click was successful
    System.out.println("Mouse was clicked at (" + mouseX + "," + mouseY + ")");
    System.out.println("Grid location: " + grid.getGridLocation());

    //what to do if clicked? (Make player1 disappear?)


    //Toggle the animation on & off
    doAnimation = !doAnimation;
    System.out.println("doAnimation: " + doAnimation);
    //grid.setMark("X",grid.getGridLocation());
    
  }





//------------------ CUSTOM  METHODS --------------------//

//method to update the Title Bar of the Game
public void updateTitleBar(){

  if(!isGameOver()) {
    //set the title each loop
    surface.setTitle(titleText + "    " + extraText);

    //adjust the extra text as desired
  
  }

}

//method to update what is drawn on the screen each frame
public void updateScreen(){

  //update the background
  background(bg);

  //Display the Player1 image
  GridLocation player1Loc = new GridLocation(player1.getX(), player1.getY());
  grid.setTileImage(player1Loc, player1.getImage());
    GridLocation player2loc = new GridLocation(player2.getX(), player2.getY());
    grid.setTileImage(player2loc,player2.getImage());
  for (int i = 0; i < blocklist.size(); i++){
    Block b = blocklist.get(i);
    grid.setTileImage(b.getLocation(),b.getImage());
  }
    for (int i = 0; i < blocklist2.size(); i++){
    Block b = blocklist.get(i);
    grid.setTileImage(b.getLocation(),b.getImage());
  }
  //Loop through all the Tiles and display its images/sprites
  

      //Store temporary GridLocation
      
      //Check if the tile has an image/sprite 
      //--> Display the tile's image/sprite



  //update other screen elements

}

//Method to populate enemies or other sprites on the screen
public void populateSprites(){
  
  //What is the index for the last column?
  

  //Loop through all the rows in the last column
  
    //Generate a random number
    

    //10% of the time, decide to add an enemy image to a Tile
    

}

//Method to move around the enemies/sprites on the screen
public void moveSprites(){
  //Loop through all of the rows & cols in the grid
  
    //Store the 2 tile locations to move

    //Check if the current tile has an image that is not player1      


      //Get image/sprite from current location


      //CASE 1: Collision with player1


      //CASE 2: Move enemy over to new location

      
      //Erase image/sprite from old location
      
      //System.out.println(loc + " " + grid.hasTileImage(loc));


    //CASE 3: Enemy leaves screen at first column


}

//Method to handle the collisions between Sprites on the Screen
public void handleCollisions(){


}

//method to indicate when the main game is over
public boolean isGameOver(){
  return false; //by default, the game is never over
}

//method to describe what happens after the game is over
public void endGame(){
    System.out.println("Game Over!");

    //Update the title bar

    //Show any end imagery
    image(endScreen, 100,100);

}

//example method that creates 5 horses along the screen
public void exampleAnimationSetup(){  
  int i = 2;
  exampleSprite = new AnimatedSprite("sprites/horse_run.png", 50.0f, i*75.0f, "sprites/horse_run.json");
}

//example method that animates the horse Sprites
public void checkExampleAnimation(){
  if(doAnimation){
    exampleSprite.animateVertical(5.0f, 0.1f, true);
  }
}
/* Animated Sprite class - useful to have Sprites move around
 * Designed to be used with Spritesheets & JSON Array files from TexturePacker software: 
 * https://free-tex-packer.com/app/
 * Inspired by Daniel Shiffman's p5js Animated Sprite tutorial: https://youtu.be/3noMeuufLZY
 * Author: Joel Bianchi
 * Last Edit: 5/22/2023
 */
 
public class AnimatedSprite extends Sprite{
  
    private String jsonPath;
    private ArrayList<PImage> animation;
    private int len;
    private float i_bucket;

    JSONObject spriteData;
    PImage spriteSheet;

  // Constructor for AnimatedSprite with Spritesheet (Must use the TexturePacker to make the JSON)
  // https://www.codeandweb.com/texturepacker
  public AnimatedSprite(String png, float x, float y, String json) {
    super(png, x, y, 1.0f, true);

    this.jsonPath = json;
    this.animation = new ArrayList<PImage>();
 
    spriteData = loadJSONObject(json);
    spriteSheet = loadImage(png);
    JSONArray frames = spriteData.getJSONArray("frames");
    
    System.out.println("Loading Animated Sprite...");
    for(int i=0; i<frames.size(); i++){

      JSONObject frame = frames.getJSONObject(i);
      //System.out.println(i + ": " + frame + "\n");
      JSONObject fr = frame.getJSONObject("frame");
      //System.out.println("ss: " + fr + "\n");

      int sX = fr.getInt("x");
      int sY = fr.getInt("y");
      int sW = fr.getInt("w");
      int sH = fr.getInt("h");
      System.out.println(i + ":\t sX:" + sX + ":\t sY:" + sY + ":\t sW:" + sW + ":\t sH:" + sH);
      PImage img = spriteSheet.get(sX, sY, sW, sH);
      animation.add(img);

      this.len = this.animation.size();
      this.i_bucket = 0;
    }
    
    super.setW(this.animation.get(0).width);
    super.setH(this.animation.get(0).height);
    super.setLeft(x);
    super.setTop(y);
    //System.out.println("AS w: " + super.getW() + ",h: " + super.getH());
  }

  
  //Overriden method: Displays the correct frame of the Sprite image on the screen
  public void show() {
    int index = (int) Math.floor(Math.abs(this.i_bucket)) % this.len;
    image(animation.get(index), super.getLeft(), super.getTop());
    //System.out.println("Pos: "+ super.getX() +"," + super.getY());
  } 

  //Method to cycle through the images of the animated sprite
  public void animate(float animationSpeed){
    i_bucket +=  animationSpeed * 1;
    show();
  }

  //Method that makes animated sprite move in any straight line
  public void animateMove(float hSpeed, float vSpeed, float animationSpeed, boolean wraparound){
    
    //adjust speed & frames
    animate(animationSpeed);
    super.move( (int) (hSpeed * 10), (int) (vSpeed * 10) );
  
    //wraparound sprite if goes off the right or left
    if(wraparound){
      wraparoundHorizontal();
      wraparoundVertical();
    }
  }

  //animated method that makes the Sprite move to the right-left
  public void animateHorizontal(float horizontalSpeed, float animationSpeed, boolean wraparound) {
    animateMove(horizontalSpeed, 0, animationSpeed, wraparound);
  }

  //animated method that makes the Sprite move down-up
  public void animateVertical(float verticalSpeed, float animationSpeed, boolean wraparound) {
    animateMove(0, verticalSpeed, animationSpeed, wraparound);
  }

  //Accessor method for the JSON path
  public String getJsonPath(){
    return this.jsonPath;
  }

  //---------------------PRIVATE HELPER METHODS--------------------------//

  //wraparound sprite if goes off the right-left
  private void wraparoundHorizontal(){
    if ( super.getLeft() > width ) {
      super.setLeft( -super.getW() );
    } else if ( super.getRight() < -width ){
      super.setRight( width );
    }
  }

  //wraparound sprite if goes off the top-bottom
  private void wraparoundVertical(){
    if ( super.getTop() > height ) {
      super.setTop( -super.getH() );
    } else if ( super.getBottom() < -height ){
      super.setBottom( height );
    }
  }

}
public class Block {

    private GridLocation loc;
    private PImage Pi;

    public Block(PImage P){
        this(P,0,0);
    }
    public Block(PImage P, GridLocation l){
        Pi = P;
        loc = l;
    }
    public Block(PImage P, int x, int y){
        Pi = P;
        loc = new GridLocation(x,y);
    }
    public GridLocation getLocation(){
        return loc;
    }
    public PImage getImage(){
        return Pi;
    }
    public void updateLocation(GridLocation l){
        loc = l;
    }
    public void updateLocation(int x,int y){
        loc = new GridLocation(x,y);
    }
    public void updateImage(PImage P){
        Pi = P;
    }
}
/* Grid Class - Used for rectangular-tiled games
 * A 2D array of GridTiles which can be marked
 * Author: Joel Bianchi
 * Last Edit: 5/24/2023
 * Edited to show all Images & Sprites
 */

public class Grid{
  
  private int rows;
  private int cols;
  private GridTile[][] board;
  

  //Grid constructor that will create a Grid with the specified number of rows and cols
  public Grid(int rows, int cols){
    this.rows = rows;
    this.cols = cols;
    board = new GridTile[rows][cols];
    
    for(int r=0; r<rows; r++){
      for(int c=0; c<cols; c++){
        board[r][c] = new GridTile(new GridLocation(r,c));
      }
    }
  }

  // Default Grid constructor that creates a 3x3 Grid  
  public Grid(){
     this(3,3);
  }

 
  // Method that Assigns a String mark to a location in the Grid.  
  // This mark is not necessarily visible, but can help in tracking
  // what you want recorded at each GridLocation.
  public void setMark(String mark, GridLocation loc){
    board[loc.getRow()][loc.getCol()].setNewMark(mark);
    //printGrid();
  } 

  // Method that Assigns a String mark to a location in the Grid.  
  // This mark is not necessarily visible, but can help in tracking
  // what you want recorded at each GridLocation.  
  // Returns true if mark is correctly set (no previous mark) or false if not
  public boolean setNewMark(String mark, GridLocation loc){
    int row = loc.getRow();
    int col = loc.getCol();
    boolean isGoodClick = board[row][col].setNewMark(mark);
    printGrid();
    return isGoodClick;
  }
  public String getMark(GridLocation loc){
    return board[loc.getRow()][loc.getCol()].getMark();
  }
  public boolean removeMark(GridLocation loc){
    boolean isGoodClick = board[loc.getRow()][loc.getCol()].removeMark();
    return isGoodClick;
  }
  public boolean hasMark(GridLocation loc){
    boolean isGoodClick = board[loc.getRow()][loc.getCol()].getMark() != " ";
    return isGoodClick;
  } 
  
  //Method that prints out the marks in the Grid to the console
  public void printGrid(){
   
    for(int r = 0; r<rows; r++){
      for(int c = 0; c<cols; c++){
         System.out.print(board[r][c]);
      }
      System.out.println();
    } 
  }
  
  //Method that returns the GridLocation of where the mouse is currently hovering over
  public GridLocation getGridLocation(){
      
    int row = mouseY/(pixelHeight/this.rows);
    int col = mouseX/(pixelWidth/this.cols);

    return new GridLocation(row, col);
  } 

  //Accessor method that provide the x-pixel value given a GridLocation loc
  public int getX(GridLocation loc){
    int widthOfOneTile = pixelWidth/this.cols;
    //calculate the left of the grid GridLocation
    int pixelX = (widthOfOneTile * loc.getCol()); 
    return pixelX;
  }
  public int getX(int row, int col){
    return getX(new GridLocation(row, col));
  }
  
  //Accessor method that provide the y-pixel value given a GridLocation loc
  public int getY(GridLocation loc){
    int heightOfOneTile = pixelHeight/this.rows;
    //calculate the top of the grid GridLocation
    int pixelY = (heightOfOneTile * loc.getRow()); 
    return pixelY;
  }
  public int getY(int row, int col){
    return getY(new GridLocation(row,col));
  }

  
  //Accessor method that returns the number of rows in the Grid
  public int getNumRows(){
    return rows;
  }
  
  //Accessor method that returns the number of cols in the Grid
  public int getNumCols(){
    return cols;
  }

  //Accessor method that returns the width of 1 Tile in the Grid
  public int getTileWidthPixels(){
    return pixelWidth/this.cols;
  }
  //Accessor method that returns the height of 1 Tile in the Grid
  public int getTileHeightPixels(){
    return pixelHeight/this.rows;
  }


  //Returns the GridTile object stored at a specified GridLocation
  public GridTile getTile(GridLocation loc){
    return board[loc.getRow()][loc.getCol()];
  }

  //Returns the GridTile object stored at a specified row and column
  public GridTile getTile(int r, int c){
    return board[r][c];
  }

  //------------------PImage Methods ---------------//
  //Method that sets the image at a particular tile in the grid & displays it
  public void setTileImage(GridLocation loc, PImage pi){
    GridTile tile = getTile(loc);
    tile.setImage(pi);
    showTileImage(loc);
  }

  //Method that returns the PImage associated with a particular Tile
  public PImage getTileImage(GridLocation loc){
    GridTile tile = getTile(loc);
    return tile.getImage();
  }


  //Method that returns if a Tile has a PImage
  public boolean hasTileImage(GridLocation loc){
    GridTile tile = getTile(loc);
    return tile.hasImage();
  }

  //Method that clears the tile image
  public void clearTileImage(GridLocation loc){
    setTileImage(loc,null);
  }

  public void showTileImage(GridLocation loc){
    GridTile tile = getTile(loc);
    if(tile.hasImage()){
      image(tile.getImage(),getX(loc),getY(loc));
    }
  }

  //Method to show all the PImages stored in each GridTile
  public void showImages(){

    //Loop through all the Tiles and display its images/sprites
      for(int r=0; r<getNumRows(); r++){
        for(int c=0; c<getNumCols(); c++){

          //Store temporary GridLocation
          GridLocation tempLoc = new GridLocation(r,c);
          
          //Check if the tile has an image
          if(hasTileImage(tempLoc)){
            showTileImage(tempLoc);
          }
        }
      }
  }

  //------------------AnimatedSprite Methods ---------------//
  //Method that sets the Sprite at a particular tile in the grid & displays it
  public void setTileSprite(GridLocation loc, AnimatedSprite sprite){
    GridTile tile = getTile(loc);
    if(sprite == null){
      tile.setSprite(null);
      //System.out.println("Cleared tile @ " + loc);
      return;
    }
    sprite.setLeft(getX(loc));
    sprite.setTop(getY(loc));
    tile.setSprite(sprite);
    showTileSprite(loc);
    //System.out.println("Succcessfully set tile @ " + loc);
  }
  
  //Method that returns the PImage associated with a particular Tile
  public AnimatedSprite getTileSprite(GridLocation loc){
    GridTile tile = getTile(loc);
    //System.out.println("Grid.getTileSprite() " + tile.getSprite());
    return tile.getSprite();
  }
  
  //Method that returns if a Tile has a PImage
  public boolean hasTileSprite(GridLocation loc){
    GridTile tile = getTile(loc);
    return tile.hasSprite();
  }

  //Method that clears the tile image
  public void clearTileSprite(GridLocation loc){
    setTileSprite(loc,null);
  }

  public void showTileSprite(GridLocation loc){
    GridTile tile = getTile(loc);
    if(tile.hasSprite()){
      tile.getSprite().animateMove(0.0f, 0.0f, 1.0f, true);
    }
  }

  
  //Method to show all the PImages stored in each GridTile
  public void showSprites(){

    //Loop through all the Tiles and display its images/sprites
      for(int r=0; r<getNumRows(); r++){
        for(int c=0; c<getNumCols(); c++){

          //Store temporary GridLocation
          GridLocation tempLoc = new GridLocation(r,c);
          
          //Check if the tile has an image
          if(hasTileSprite(tempLoc)){
            setTileSprite(tempLoc, getTileSprite(tempLoc));
            //showTileSprite(tempLoc);
          }
        }
      }
  }







  public void pause(final int milliseconds) {
    try {
      Thread.sleep(milliseconds);
    } catch (final Exception e) {
      // ignore
    }
  }


}
/* GridLocation class - helper class to store coordinates more easily
 * Author: Joel Bianchi
 * Last Edit: 5/22/2023
 * Added .equals() method, Renamed getRow() & getCol()
 */

public class GridLocation{
 
  int row;
  int col;
  
  public GridLocation(int row, int col){
    this.row = row;
    this.col = col;
  }
  
  public int getRow(){
    return row;
  }
  
  public int getCol(){
    return col;
  }
  
  public String toString(){
    return row + "," + col;
  }
  
  public int getYCoord() {
    return row;
  }
  
  public int getXCoord() {
    return col;
  }

  public boolean equals(GridLocation otherLoc){
    if(getRow() == otherLoc.getRow() && getCol() == otherLoc.getCol()){
      return true;
    }
    return false;

  }
 
}
/* GridTile class - Designed to be used within the Grid class
 * GridTiles have distinguishable marks that will be printed out to the console for easy visualization of a 2D array
 * GridTiles can indicate if they have been "captured", colored, or are displaying an image
 * Authors: Joel Bianchi, Naomi Gaylor, Ezzeldin Moussa
 * Last Edit: 5/23/2023
 * Edited to be superclass of HexTile, included hasImage() function
 */



public class GridTile{
  
  private GridLocation location;
  private PImage pi;
  private AnimatedSprite sprite;
  private boolean coveredPic;
  private int fillColor;
  final int defaultFillColor = 0xFFFFFFFF; //WHITE
  private int outlineColor;
  final int defaultOutlineColor = 0xFF000000; //BLACK
  private String mark;
  final private static String noMark = " ";
  private boolean isCaptured;

  //------------------GridTile Constructors ---------------//
  //GridTile constructor #1: Adds the specified String mark
  public GridTile(String mark, GridLocation loc){
    this.mark = mark;
    location = loc;
    fillColor = defaultFillColor;
    outlineColor = defaultOutlineColor;
    coveredPic = false;
  }
  
  //GridTile constructor #2 which adds a mark, but no Location
  public GridTile(String mark){
    this(mark, null);
  }

  //GridTile constructor #3 which adds a GridLocation, but no mark  
  public GridTile(GridLocation loc){
    this(noMark, loc);
  }

  //Default GridTile constructor which puts an empty String mark in the GridTile
  public GridTile(){
    this(noMark, null);
  }

  //------------------Marking Methods ---------------//
  // Accessor method that gets the mark in the GridTile
  public String getMark(){
    return mark;
  }
  
  // Mutator method that automatically changes the mark
  public void setMark(String mark){
    this.mark = mark;
  }

  // Mutator method sets a new mark in the GridTile 
  // if it does not already have a mark, 
  // returns true or false if successful
  public boolean setNewMark(String mark){
    if(this.mark.equals(noMark)){
      this.mark = mark;
      System.out.println("Successfully changed mark");
      return true;
    } else {
      System.out.println("That GridTile is already taken!");
      return false;
    }
  }

  public boolean removeMark(){
    if(this.mark.equals(noMark)){
      return false;
    }
    else{
      this.mark = noMark;
      return true;
    }
  }
  
  //------------------PImage Methods ---------------//
  // Mutator method that sets a new PImage in the GridTile
  public void setImage(PImage pi){
    this.pi = pi;
  }

  //Accessor method that returns the PImage stored in the GridTile
  public PImage getImage(){
    return pi;
  }

  //Method to check if the GridTile has an PImage in it
  public boolean hasImage(){
    if(pi == null){
      return false;
    }
    return true;
  }

  //------------------Sprite Methods ---------------//
 // Mutator method that sets a new AnimatedSprite in the GridTile
  public void setSprite(AnimatedSprite sprite){
    this.sprite = sprite;
  }

  //Accessor method that returns the AnimatedSprite stored in the GridTile
  public AnimatedSprite getSprite(){
    return sprite;
  }

  //Method to check if the GridTile has an AnimatedSprite in it
  public boolean hasSprite(){
    if(sprite == null){
      return false;
    }
    return true;
  }

  //------------------Capturing Tiles Methods ---------------//
  //method to "capture" a tile by changing its color
  public void captureTile(int clr){
    this.isCaptured = false;
    this.fillColor = clr;
  }

  //method to "release" a tile by changing its color
  public void releaseTile(){
    this.isCaptured = false;
    this.fillColor = defaultFillColor;
  }

  //accessor method to check if tile is captured
  public boolean checkIsCaptured(){
    return isCaptured;
  }


  //------------------Coloring Tiles Methods ---------------//
  //method to change the color of the tile
  public void setColor(int clr) {
    this.fillColor = clr;
  }

  //method to access the color of the tile
  public int getColor() {
    return fillColor;
  }

  public void setOutlineColor(int oclr){
    this.outlineColor = oclr;
  }

  public int getOutlineColor(){
    return this.outlineColor;
  }

  public void setCoveredWithPic(boolean isCoveredWithPic) {
    this.coveredPic = isCoveredWithPic;
  }

  public boolean isCoveredWithPic() {
    return this.coveredPic;
  }



  //method to access the location of the GridTile
  public GridLocation getLocation(){
      return location;
  }

  //ToString simply retuns the mark on the Tile, useful for printing out 2D grids
  public String toString(){
    return mark;
  }


}
/* HexGrid Class - useful for tile-based games with more flavor!
 * Inspired from CSRessel's Catan Game & Emmanuel Suriel's Grid class
 * https://github.com/CSRessel/catan/blob/master/src/gui/CatanBoard.java
 * Adapted for Processing
 * Authors: Joel Bianchi, Naomi Gaylor, Ezzeldin Moussa
 * Last Edit: 5/16/2023
 * NOT FULLY FUNCTIONAL YET
 */





public class HexGrid {

	ArrayList<HexLocation> allHexLocations;
	ArrayList<HexLocation> unclaimedLocations;
	
    private HexTile[][] map;
    private int defaultOutlineColor = 0xFFFFFFFF;	//WHITE
    private int defaultFillColor = 0xFF000000; 		//BLACK
	private int defaultBgColor = color(164,200,218);
	
	private boolean bgSet = false;

    //GUI fields
	private int hexGen;
	private int hexDiameter;
	private int boardHeight;
	private int hexagonSide;
	private int heightMargin = 100;
	private int widthMargin;
	private final double sqrt3div2 = 0.86602540378f;

    //HexGrid Constructor
    public HexGrid(int hexGen){

		this.hexGen = hexGen;

		//Generate all the valid hexLocations
		allHexLocations = new ArrayList<HexLocation>();
        
		hexDiameter = hexGen *2 -1;	//originally 5
		int midHex = hexGen;	//originally 3
		System.out.println("mid:" + midHex);

		//Create top half of HexLocations
		for(int r=1; r <= midHex; r++){
			for(int c=1; c <= midHex + r - 1; c++){
				allHexLocations.add( new HexLocation(c,r) );
			}
		}
		//Create bottom half of HexLocations
		for(int r = midHex +1; r <= hexDiameter; r++){
			for(int c= r-midHex + 1; c <= hexDiameter; c++){
				allHexLocations.add( new HexLocation(c,r) );
			}
		}
		
		System.out.println("All generated HexLocations:");
		System.out.println(allHexLocations);

		//Construct 2D array of HexTiles
		int row = hexDiameter + 2;
		int col = row;
        map = new HexTile[row][col];

		//Initialize unclaimed HexLocations arrayList
		unclaimedLocations = new ArrayList<HexLocation>();

		for(HexLocation loc: allHexLocations){

			//Generate hexTiles for each HexLocation
			HexTile hTile = new HexTile(loc, this.hexDiameter);
			map[loc.getYCoord()][loc.getXCoord()] = hTile;
			hTile.setColor(defaultFillColor);
			hTile.setOutlineColor(defaultOutlineColor);
			setHexTileCenterPixels(hTile);
			setHexTilePoly(hTile);

			//Generate unclaimedTiles ArrayList
			unclaimedLocations.add(loc);
		}
    }

	public boolean isValidLocation(HexLocation testLoc){
		for(int i=0; i<unclaimedLocations.size(); i++){
			if(unclaimedLocations.get(i).equals(testLoc)){
				return true;
			}
		}
		return false;
	}

	public boolean isWithinOne(HexLocation start, HexLocation end){
		int startX = start.getXCoord();
		int startY = start.getYCoord();
		int endX = end.getXCoord();
		int endY = end.getYCoord();

		if(endX==startX+1 || endX==startX-1 || endX==startX){
			if(endY==startY+1 || endY==startY-1 || endY==startY){
				return true;
			}
		}
		return false;
	}

	public boolean isWithinTwo(HexLocation start, HexLocation end){
		int startX = start.getXCoord();
		int startY = start.getYCoord();
		int endX = end.getXCoord();
		int endY = end.getYCoord();

		if(endX==startX+2 || endX==startX+1 || endX==startX-2 || endX==startX-1 || endX==startX){
			if(endY==startY+2 || endY==startY+1 || endY==startY-2 || endY==startY-1 || endY==startY){
				return true;
			}
		}
		return false;
	}

	public void removeHexLocation(HexLocation loc){
		for(int i=0; i<unclaimedLocations.size(); i++){
      		if(unclaimedLocations.get(i).equals(loc)){
        		unclaimedLocations.remove(i);
				return;
			}
		}
		System.out.println("Error when trying to remove Location: " + loc);
	}


	public void displayHexGrid(){

        int mapHeight = map.length;
        //int hexagonSide = 50;
		//int hexagonSide = (mapHeight - 2 * heightMargin) / 8;
        int widthMargin = (width - (int) (10 * hexagonSide * sqrt3div2)) / 2;

        // Graphics2D g2 = (Graphics2D)g;
        // g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        // g.setFont(new Font("TimesRoman", Font.PLAIN, 20));
        // super.paintComponent(g2);

		//System.out.println("ahl size: " + allHexLocations.size());

		//Fill in each Hex
		for(HexLocation loc: allHexLocations){
			int x = loc.getXCoord();
			int y = loc.getYCoord();
			HexTile hTile = map[x][y];
			//System.out.println(hTile);
			fillOneHex(hTile);
		}

		//Outline each Hex
		for(HexLocation loc: allHexLocations){
			int x = loc.getXCoord();
			int y = loc.getYCoord();
			HexTile hTile = map[x][y];
			outlineOneHex(hTile);
		}

		//System.out.println("HexLocations: " + hexLocations);
    }

	private void setHexTileCenterPixels(HexTile hTile){
		int x = hTile.getLocation().getXCoord();
        int y = hTile.getLocation().getYCoord();
		Point centerPixels = findTileCenter(hTile);
		hTile.setHexCenterPixels(centerPixels);
	}

	private void setHexTilePoly(HexTile hTile){
        Polygon hexPoly = makeHex(hTile.getCenterPixels());
		hTile.setHexPoly(hexPoly);
	}

	//method to fill in 1 hex tile
    public void fillOneHex(HexTile hTile){

        boolean hasImage = hTile.isCoveredWithPic();
		//System.out.println("drawHex: x:"+tile.getLocation().getXCoord()+",y:"+tile.getLocation().getYCoord());
		
        //FILL IN SOLID COLOR - fill in hexTile with a solid color if no picture
        if(!hasImage){
			int fillClr = hTile.getColor();
			
			// ???

		}
    		
        //FILL IN PICTURE
        if(hasImage){    
			PImage photo = hTile.getImage();
			
			try{
				//resize the image to fit in the hex
				int iSize = (int) (hexagonSide * 1.25f);
				photo.resize(iSize, iSize);

				//mask the image to the hex shape
				PGraphics maskImage;
				maskImage = createGraphics(iSize,iSize);
				maskImage.beginDraw();
				//maskImage.triangle(30, 480, 256, 30, 480, 480);
				//maskImage = drawOneHex(PGraphics maskImage);
				maskImage.endDraw();
				
				// apply mask
				photo.mask(maskImage);

				//display masked image
				image(photo, 0, 0);

				final int ix = getImageX(hTile, photo);
				final int iy = getImageY(hTile, photo);
				
				//System.out.println("Img: " + locImageName);
				//System.out.println("nPoints:" + poly.npoints);
				//System.out.println("ix:" + ix + "\tiy:"+iy);

				//System.out.println("Drew image for x:" + x + ",y:" + y);

			} catch(Exception e){

			} //end catch
		} //end image fill
	} //end drawing one hex

	//method to draw the outline around a hex tile
    public void outlineOneHex(HexTile hTile){
		int oClr = hTile.defaultOutlineColor;
		float stroke = 3.0f;
		int tileOutlineColor = hTile.getOutlineColor();
		
		if(tileOutlineColor != oClr){
			PGraphics pg = getHexPGraphics(hTile);

			//DRAW THE OUTLINE!???

		}
	}


//---------------------- HELPER METHODS -------------------------------//
    private int getImageX(HexTile hTile, PImage image){
    	Point center = findTileCenter(hTile);
        int imageWidth =  image.width;
        return center.x - imageWidth/2; 
    }
    private int getImageY(HexTile hTile, PImage image){        
        Point center = findTileCenter(hTile);
        int imageHeight =  image.height;
        return center.y - imageHeight/2; 
    }

	//method finds the center pixels of a HexTile based on its grid coordinates
	private Point findTileCenter(HexTile hTile){
		return findTileCenter(hTile.getLocation().getXCoord(), hTile.getLocation().getYCoord());
	}
	private Point findTileCenter(int xcoord, int ycoord){
		int x = xcoord;
		int y = ycoord;
		//code for a bottom left origin with rows as x and cols as y
		// int xCenter = widthMargin + (int) (3 * hexagonSide * sqrt3div2)
		// 		+ (int) ((x - 1) * 2 * hexagonSide * sqrt3div2)
		// 		- (int) ((y - 1) * hexagonSide * sqrt3div2);
		// int yCenter = boardHeight - (heightMargin + hexagonSide
		// 		+ (int) ((y - 1) * hexagonSide * 1.5));

		//code for a top left origin (to mimic how Java 2D arrays are modeled) with rows as y and cols as x
		int xCenter = widthMargin + (int) (3 * hexagonSide * sqrt3div2)
		+ (int) ((x - 1) * 2 * hexagonSide * sqrt3div2)
		- (int) ((y - 1) * hexagonSide * sqrt3div2);
		
		int yCenter = (heightMargin + hexagonSide 
		+ (int) ((y - 1) * hexagonSide * 1.5f));

		return new Point(xCenter,yCenter);
	}



    //MUTATOR METHODS
    public void setAllTileColors(int tileColor){
        this.defaultFillColor = tileColor;
          for (int r = 0; r < map.length; r++) {
            for (int c = 0; c < map[0].length; c++) {
                if (map[r][c] != null){
                    map[r][c].setColor(defaultFillColor);
                }
            }
        }
    }

	public void setAllTileOutlines(int outlineColor){
        this.defaultFillColor = outlineColor;
          for (int r = 0; r < map.length; r++) {
            for (int c = 0; c < map[0].length; c++) {
                if (map[r][c] != null){
                    map[r][c].setOutlineColor(defaultFillColor);
                }
            }
        }


    }


	//method to access any Hextile based on its location
    public HexTile getHexTile(HexLocation loc){
		int x = loc.getXCoord();
		int y = loc.getYCoord();
        return map[x][y];
    }

    public int setTileColor(HexLocation loc, int tileColor){
		HexTile hTile = getHexTile(loc);
        int oldColor = hTile.getColor();
        hTile.setColor(tileColor);
        return oldColor;
    }

	public void highlightTile(HexLocation loc) {
		HexTile hTile = getHexTile(loc);
		int highlightColor = 0xFFFFFFFF;

		Point p = hTile.getCenterPixels();

		//Shape shape = new Ellipse2D.Double((int)p.getX() - 25, (int)p.getY() - 25, 50, 50);

		// g2.setColor(Color.WHITE);
		// g2.fill(shape);
		// g2.draw(shape);
	}
    


    /* ---------------  HEX GRID ACCESSOR METHODS ------------------ */
	public HexTile[][] getMap(){
        return map;
    }
    
    public int getNumRows() {
		return map.length;
	}

	public int getNumCols() {
		return map[0].length;
	}

    //needs to be modified slightly because HexGrid doesn't include ALL tiles in the rectangle (like 0,0)
	public boolean isValid(final HexLocation loc) {
		final int row = loc.getYCoord();
		final int col = loc.getXCoord();
		return 0 <= row && row < getNumRows() && 0 <= col && col < getNumCols();
	}


    /* ---------------- BACKGROUND IMAGE METHODS ------------------------- */



	/**
	 * sets the background to imgName. The img is resized to fit in the grids
	 * dimensions. setColor() is disabled
	 * 
	 * @param imgName
	 */
	public void setBackground(PImage bgImage) {
		// this.xOffset = 0;
		// this.yOffset = 0;
		// this.xScale = 1.0;
		// this.yScale = 1.0;

		// backgroundImage = loadImage(imgName);
		// bgSet = true;

		//repaint();
	}

	/**
	 * Removes a regular background or moveable background, allowing setColor to
	 * work again.
	 */
	public void removeBackground() {
		bgSet = false;
	}



	public void setFillColor(final HexLocation loc, final int clr) {
		if (!isValid(loc))
			throw new RuntimeException("cannot set color of invalid location " + loc + " to color " + clr);
		map[loc.getXCoord()][loc.getYCoord()].setColor(clr);
		//repaint();
	}

	public int getFillColor(final HexLocation loc) {
		if (!isValid(loc))
			throw new RuntimeException("cannot get color from invalid location " + loc);
		return map[loc.getYCoord()][loc.getXCoord()].getColor();
	}

	// public void setImage(final HexLocation loc, final String imageFileName) {
	// 	if (!isValid(loc))
	// 		throw new RuntimeException(
	// 				"cannot set image for invalid location " + loc + " to \"" + imageFileName + "\"");
	// 	map[loc.getXCoord()][loc.getYCoord()].setImageFileName(imageFileName);
	// 	repaint();
	// }

	// public String getImage(final Location loc) {
	// 	if (!isValid(loc))
	// 		throw new RuntimeException("cannot get image for invalid location " + loc);
	// 	return map[loc.getYCoord()][loc.getXCoord()].getImageFileName();
	// }

	public void setTileOutlineColor(final HexLocation loc, final int oclr) {
		if (!isValid(loc))
			throw new RuntimeException("cannot set outline for invalid location " + loc);
            map[loc.getXCoord()][loc.getYCoord()].setOutlineColor(oclr);
		//repaint();
	}

	public int getTileOutlineColor(final HexLocation loc) {
		if (!isValid(loc))
			throw new RuntimeException("cannot get outline color for invalid location " + loc);
		return map[loc.getXCoord()][loc.getYCoord()].getOutlineColor();
	}

	public void setAllOutlinesColor(final int oclr) {
		for (int r = 0; r < getNumRows(); r++) {
			for (int c = 0; c < getNumCols(); c++) {
				map[r][c].setOutlineColor(oclr);
			}
		}
		//repaint();
	}



    /* ----- INPUT HANDLING -------------------------------------------------------------------- */
	// // returns -1 if no key pressed since last call.
	// // otherwise returns the code for the last key pressed.
	// public int checkLastKeyPressed() {
	// 	final int key = lastKeyPressed;
	// 	lastKeyPressed = -1;
	// 	return key;
	// }

	// // returns null if no location clicked since last call.
	// public HexLocation checkLastLocationClicked() {
	// 	final HexLocation loc = lastLocationClicked;
	// 	lastLocationClicked = null;
	// 	return loc;
	// }

	// public HexLocation waitForClick() {
	// 	while (true) {
	// 		final HexLocation clicked = this.checkLastLocationClicked();
	// 		if (clicked != null) {
	// 			//System.out.print("x:"+clicked.getXCoord()+ ",y:" + clicked.getYCoord());
	// 			return clicked;
	// 		} else {
	// 			//System.out.print("NOT CLICKED");
	// 			HexGrid.pause(100);
	// 		}
	// 	}
	// }

    // public static void pause(final int milliseconds) {
	// 	try {
	// 		Thread.sleep(milliseconds);
	// 	} catch (final Exception e) {
	// 		// ignore
	// 	}
	// }

    // public void keyPressed(final KeyEvent e) {
	// 	lastKeyPressed = e.getKeyCode();
	// }

	// public void mousePressed(final MouseEvent e) {

	// 	Point p = e.getPoint();
	// 	//System.out.println(p);
		
	// 	for(HexLocation loc : this.allHexLocations){
	// 		HexTile hTile = map[loc.getXCoord()][loc.getYCoord()];
	// 		Polygon hexPoly = hTile.getHexPoly();
	// 		if(hexPoly.contains(p)){
				
	// 			lastLocationClicked = loc;
				
	// 		}
	// 	}
	// }



    // ------------------ GUI HELPER METHODS --------------------------------------------------------------------------//

    // private void guiInit() {
    //     lastKeyPressed = -1;
    //     lastLocationClicked = null;

    //     frame = new JFrame("Grid");
    //     frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	// 	fullscreen();	//makes the it stay on the left??
    //     frame.addKeyListener(this);

    //     int mapSize = Math.max(Math.min(500 / getNumRows(), 500 / getNumCols()), 1);
    //     setPreferredSize(new Dimension(mapSize * getNumCols(), mapSize * getNumRows()));
    //     addMouseListener(this);
    //     frame.getContentPane().add(this);

    //     frame.pack();
    //     frame.setVisible(true);

	// 	setBackground(defaultBgColor); //TODO add background

	// 	boardHeight = getHeight();
	// 	hexagonSide = 250 / (hexGen + 2);
	// 	//hexagonSide = 25;
	// 	//hexagonSide = (boardHeight - 2 * heightMargin) / 8;
	// 	widthMargin = (getWidth() - (int) (10 * hexagonSide * sqrt3div2)) / 2;
	// 	System.out.println("Boardheight: " + boardHeight);
	// 	System.out.println("HexagonSide: " + hexagonSide);
	// 	System.out.println("WidthMargin: " + widthMargin);

	// 	this.addComponentListener(new ComponentListener() {

    // 		public void componentResized(ComponentEvent e) {
    // 		//	System.out.println(e.getComponent().getSize());
    // 			boardHeight = getHeight();
    // 			//hexagonSide = (boardHeight - 2 * heightMargin) / 8;
    // 			widthMargin = (getWidth() - (int) (10 * hexagonSide * sqrt3div2)) / 2;
    // 			//System.out.println("Boardheight: " + boardHeight);
    // 			//System.out.println("HexagonSide: " + hexagonSide);
    // 			//System.out.println("WidthMargin: " + widthMargin);
    // 		}

    // 		public void componentHidden(ComponentEvent e) {}

    // 		public void componentMoved(ComponentEvent e) {}

    // 		public void componentShown(ComponentEvent e) {}
    // 	});

    // }

    // private void load(String imageFileName) {
    //     showFullImage(loadImage(imageFileName));
    //     setTitle(imageFileName);
    // }

    // private void save(String imageFileName) {
    //     try {
    //         BufferedImage bi = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);
    //         paintComponent(bi.getGraphics());
    //         int index = imageFileName.lastIndexOf('.');
    //         if (index == -1)
    //             throw new RuntimeException("invalid image file name:  " + imageFileName);
    //         ImageIO.write(bi, imageFileName.substring(index + 1), new File(imageFileName));
    //     } catch ( IOException e) {
    //         throw new RuntimeException("unable to save image to file:  " + imageFileName);
    //     }
    // }

	// private BufferedImage loadImage(String imageFileName) {
		
	// 	if(imageFileName == null || "".equals(imageFileName)){
	// 		System.out.println("Image is null or \"\"");
	// 		return null;
	// 	} else{
	// 		final URL url = getClass().getResource(imageFileName);
	// 		if (url == null) {
	// 			throw new RuntimeException("cannot find file:  " + imageFileName);
	// 		}
	// 		try {
	// 			return ImageIO.read(url);
	// 		} catch (IOException e) {
	// 			throw new RuntimeException("unable to read from file:  " + imageFileName);
	// 		}
	// 	}
	// }


    // private void showFullImage(BufferedImage image) {
    //     for (int row = 0; row < getNumRows(); row++) {
    //         for (int col = 0; col < getNumCols(); col++) {
    //             int x = col * image.getWidth() / getNumCols();
    //             int y = row * image.getHeight() / getNumRows();
    //             int c = image.getRGB(x, y);

    //             int red = (c & 0x00ff0000) >> 16;
    //             int green = (c & 0x0000ff00) >> 8;
    //             int blue = c & 0x000000ff;

    //             map[row][col].setColor(new Color(red, green, blue));
    //         }
    //     }
    //     repaint();
    // }

  

	// private displayHexTile(){
	// 	pushMatrix();
	// 	translate(width*0.8, height*0.5);
	// 	polygon(0, 0, 70, 6);
	// 	popMatrix();
	// }

	//function that creates a n-sided polygon on a point circle
	private void hexagon(HexTile hTile) {
		int npoints = 6;
		float x = hTile.getCenterPixels().x;
		float y = hTile.getCenterPixels().y;
		float angle = TWO_PI / npoints;
		float radius = hTile.getRadius();
		beginShape();
		for (float a = 0; a < TWO_PI; a += angle) {
			float sx = x + cos(a) * radius;
			float sy = y + sin(a) * radius;
			vertex(sx, sy);
		}
		endShape(CLOSE);
	}



	public Polygon makeHex(Point center) {
		int xCenter = (int) center.getX();
		int yCenter = (int) center.getY();

		Polygon output = new Polygon();
		output.addPoint(xCenter + 1, yCenter + hexagonSide + 1);
		output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter + (int) (.5f * hexagonSide) + 1);
		output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter - (int) (.5f * hexagonSide) - 1);
		output.addPoint(xCenter + 1, yCenter - hexagonSide - 1);
		output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter - (int) (.5f * hexagonSide) - 1);
		output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter + (int) (.5f * hexagonSide) + 1);

		return output;
	}

	public PGraphics getHexPGraphics(HexTile hTile) {

		Point centerPixels = hTile.getCenterPixels();
		int xCenter = (int) centerPixels.getX();
		int yCenter = (int) centerPixels.getY();

		PGraphics pg = new PGraphics();

		// Polygon output = new Polygon();
		// output.addPoint(xCenter + 1, yCenter + hexagonSide + 1);
		// output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter + (int) (.5 * hexagonSide) + 1);
		// output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter - (int) (.5 * hexagonSide) - 1);
		// output.addPoint(xCenter + 1, yCenter - hexagonSide - 1);
		// output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter - (int) (.5 * hexagonSide) - 1);
		// output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter + (int) (.5 * hexagonSide) + 1);

		return pg;
	}

}  
/* HexLocation Class
 * HexLocations use x & y coordinate instead of row & column designations
 * Author: Joel Bianchi
 * Last Edit: 5/16/2023
 */

public class HexLocation extends GridLocation{
 
  private int xCoord;
  private int yCoord;
  
  public HexLocation(int x, int y) {
    super(x,y);
    xCoord = x;
    yCoord = y;
  }
  
  public int getYCoord() {
    return yCoord;
  }
  
  public int getXCoord() {
    return xCoord;
  }
  
  public boolean equals(HexLocation otherLoc) {
    return yCoord == otherLoc.getYCoord() && xCoord == otherLoc.getXCoord();
  }
  
  public String toString() {
    return "(" + xCoord + ", " + yCoord + ")";
  }


}
/* HexTile Class
 * Based off code from Naomi Gaylor & Ezzeldin Moussa, June 2022
 * Last edit: 5/16/2023
 * Edited to be a subclass of GridTile pde file
 */




public class HexTile extends GridTile{
  
  private Polygon hexPoly;
  private float radius;
  private Point centerPixels;
  //private HexLocation hexLoc;

  //HexTile Constructor #1: GridLocation
  public HexTile(HexLocation loc, float rad){
    super(loc);
    //this.hexLoc = loc;
    this.radius = rad;
    this.centerPixels = new Point(0,0);
    this.hexPoly = null;
  }

  //HexTile Constructor #2: X,Y coordinates
  public HexTile(int xCord, int yCord, float rad){
    this(new HexLocation(xCord,yCord), rad);
  }

  //method to access the location of the GridTile
  // public HexLocation getLocation(){
  //     return location;
  // }

  //mutator method to define the center point of the Tile
  public void setHexCenterPixels(Point centerPixels){
    this.centerPixels = centerPixels;
  }
  //accessor method to the center point of the Tile
  public Point getCenterPixels(){
    return centerPixels;
  }

  //mutator method to change the Java Polygon object that defines the shape of the HexTile
  public void setHexPoly(Polygon hexPoly){
    this.hexPoly = hexPoly;
  }
  //accessor method to return the Java Polygon object
  public Polygon getPoly(){
    return hexPoly;
  }

  //accessor method to return the hexagon's radius
  public float getRadius(){
    return radius;
  }

    
}  
/* Platform class
 * Stub constructors provided
 * Can be used with the following tutorials:
 * https://longbaonguyen.github.io/courses/platformer/platformer.html
 * Authors: __________________
 * Last Edit: 5/17/2023
 */

public class Platform {//extends Sprite {

	//Platform defined by it's center-x and top-Y positions
	public Platform(float posXCenter, float posYTop, float platWidth, float platHeight, int clr) {

		//pass along the center-x and center-y to Sprite super
		//super(posXCenter, posYTop + (platHeight/2), clr);
		//System.out.println("PlatTopY: " + posYTop + "\tPlatCenterY: " + (posYTop + (platHeight/2)));
		// setWidth(platWidth);
		// setHeight(platHeight);
		//setColor(Color.black);
	}

	public Platform(float posXCenter, float posYTop, float platWidth, float platHeight) {
		//pass along the center-x and center-y to Sprite super
		this(posXCenter, posYTop, platWidth, platHeight, color(0,0,0));
	}

}
public class Player{    //Consider having Player extend from AnimatedSprite

    private int posx;
    private int posy;
    private PImage Pi;

    public Player(PImage P){
        this(P,0,0);
    }
    public Player(PImage P, int x, int y){
        this.Pi = P;
        this.posx = x;
        this.posy = y;
    }
    public PImage getImage(){
        return Pi;
    }
    public int getX(){
        return posx;
    }
    public int getY(){
        return posy;
    }
    public GridLocation getLocation(){
        return new GridLocation(posx,posy);
    }
    public void updateLocation(GridLocation l){
        posx = l.getRow();
        posy = l.getCol();
    }
    public void setImage(PImage P){
        Pi = P;
    }
    public void setX(int x){
        posx = x;
    }
    public void setY(int y){
        posy = y;
    }
    public void lowerX(){
        posx--;
    }
    public void lowerY(){
        posy--;
    }
    public void raiseX(){
        posx++;
    }
    public void raiseY(){
        posy++;
    }
    public boolean collisionCheck(GridLocation loc){
        if (new GridLocation(posx,posy) == loc)
        {
            return true;
        }
        return false;
    }
}
/* Sprite class - to create objects that move around with their own properties
 * Inspired by Daniel Shiffman's p5js Animated Sprite tutorial
 * Author: Joel Bianchi
 * Last Edit: 5/23/22
 * Modified to account for picture coordinates at Top, Left corner
 */

public class Sprite {
  
    PImage spriteImg;
    private String spriteImgPath;
    private float center_x = 0.0f;
    private float center_y = 0.0f;
    private float speed_x;
    private float speed_y;
    private float w;
    private float h;
    private boolean isAnimated;


  // Main Constructor
  public Sprite(String spriteImgPath, float scale, float x, float y, boolean isAnimated) {
    this.spriteImgPath = spriteImgPath;
    setLeft(x);
    setTop(y);
    System.out.println("AS topleft: "+getLeft()+","+getTop());
    this.speed_x = 0;
    this.speed_y = 0;
    this.isAnimated = isAnimated;
    if(!isAnimated){
      this.spriteImg = loadImage(spriteImgPath);
      w = spriteImg.width * scale;
      h = spriteImg.height * scale;
    }

  }

  // Simpler Constructor for Non-Animated Sprite
  public Sprite(String spriteImgPath, float x, float y) {
    this(spriteImgPath, 1.0f, x, y, false);
  }


  // method to display the Sprite image on the screen
  public void show() {
      image(spriteImg, getLeft(), getTop(), w, h);
  }

  // method to move Sprite image on the screen to a specific coordinate
  public void moveTo(float x, float y){
    setLeft(x);
    setTop(y);
  }

  // method to move Sprite image on the screen relative to current position
  public void move(float change_x, float change_y){
    this.center_x += change_x;
    this.center_y += change_y;
    //System.out.println(getLeft() + "," + getTop());
  }

  // method that automatically moves the Sprite based on its velocity
  public void update(){
    move(speed_x, speed_y);
  }


  // method to rotate Sprite image on the screen
  public void rotate(float degrees){

  }


  /*-- ACCESSOR METHODS --*/

  public float getW(){
    return w;
  }
  public float getH(){
    return h;
  }
  public float getCenterX(){
    return center_x;
  }
  public float getCenterY(){
    return center_y;
  }
  public PImage getImg(){
    return spriteImg;
  }
  public boolean getIsAnimated(){
    return isAnimated;
  }
  
  
  /*-- MUTATOR METHODS --*/
  public void setW(float w){
    this.w = w;
  }
  public void setH(float h){
    this.h=h;
  }
  public void setCenterX(float center_x){
    this.center_x = center_x;
  }
  public void setCenterY(float center_y){
    this.center_y=center_y;
  }
  public void setImg(PImage img){
    this.spriteImg = img;
  }
  public void setIsAnimated(boolean a){
    isAnimated = a;
  }


  /*-- SPRITE BOUNDARY METHODS --
    -- Used from Long Bao Nguyen
    -- https://longbaonguyen.github.io/courses/platformer/platformer.html
  */
  public void setLeft(float left){
    center_x = left + w/2;
  }
  public float getLeft(){
    return center_x - w/2;
  }
  public void setRight(float right){
    center_x = right - w/2;
  }
  public float getRight(){
    return center_x + w/2;
  }
  public void setTop(float top){
    center_y = top + h/2;
  }
  public float getTop(){
    return center_y - h/2;
  }
  public void setBottom(float bottom){
    center_y = bottom - h/2;
  }
  public float getBottom(){
    return center_y + h/2;
  }
  

  //Accessor method to the image path of the Sprite
  public String getImagePath(){
    return this.spriteImgPath;
  }
  
  //Accessor method to the image path of the Sprite
  public PImage getImage(){
    return this.spriteImg;
  }

  // //Method to check if 2 Sprites are the same (based on String)
  // public boolean equals(Sprite otherSprite){
  //   if(this.spriteImgPath.equals(otherSprite.getImagePath())){
  //     return true;
  //   }
  //   return false;
  // }

  //Method to check if 2 Sprites are the same (based on PImage)
  public boolean equals(Sprite otherSprite){
    if(this.spriteImg.equals(otherSprite.getImage())){
      return true;
    }
    return false;
  }

  public String toString(){
    return spriteImgPath + "\t" + getLeft() + "\t" + getTop() + "\t" + speed_x + "\t" + speed_y + "\t" + w + "\t" + h + "\t" + isAnimated;
  }

}


  public void settings() { size(800, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Game" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
