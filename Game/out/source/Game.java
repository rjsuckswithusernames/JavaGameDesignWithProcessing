/* autogenerated by Processing revision 1292 on 2023-05-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.Color;
import java.awt.Polygon;
import java.awt.Point;
import java.util.ArrayList;
import java.awt.Polygon;
import java.awt.Point;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Game extends PApplet {

/* Game Class Starter File
 * Last Edit: 12/13/2022
 * Authors: Raymond Morel, Muhammad Zahid
 */

//GAME VARIABLES
int maximumx = 6;
int maximumy = 8;
Grid grid = new Grid(maximumx,maximumy);
PImage bg;
PImage player1;
PImage player2;
boolean secret = false;
boolean debounce = false;
PImage endScreen;
String titleText = "Puzzle game";
String extraText = "real";
AnimatedSprite exampleSprite;
boolean doAnimation;

//INPUTS

//P1
int w = 87;
int a = 65;
int s = 83;
int d = 68;

//P2
int up = 38;
int left = 37;
int down = 40;
int right = 39;
//HexGrid hGrid = new HexGrid(3);
//import processing.sound.*;
//SoundFile song;

int player1Row = 0;
int player1Col = 0;
int player2Row = maximumx-1;
int player2Col = maximumy-1;


//Required Processing method that gets run once
public void setup() {

  //Match the screen size to the background image size
  /* size commented out by preprocessor */;

  //Set the title on the title bar
  surface.setTitle(titleText);

  //Load images used
  //bg = loadImage("images/chess.jpg");
  bg = loadImage("images/werksugvfuywegg.jpg");
  bg.resize(800,600);
  player1 = loadImage("images/x_wood.png");
  player1.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
    player2 = loadImage("images/spook.png");
  player2.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
  endScreen = loadImage("images/youwin.png");

  // Load a soundfile from the /data folder of the sketch and play it back
  // song = new SoundFile(this, "sounds/Lenny_Kravitz_Fly_Away.mp3");
  // song.play();

  
  //Animation & Sprite setup
  exampleAnimationSetup();

  println("Game started...");

  //fullScreen();   //only use if not using a specfic bg image
}

//Required Processing method that automatically loops
//(Anything drawn on the screen should be called from here)
public void draw() {

  updateTitleBar();
  updateScreen();
  populateSprites();
  moveSprites();
  
  if(isGameOver()){
    endGame();
  }

  checkExampleAnimation();

}

//Known Processing method that automatically will run whenever a key is pressed
public void keyPressed(){

  //check what key was pressed
  System.out.println("Key pressed: " + keyCode); //keyCode gives you an integer for the key

  //What to do when a key is pressed?
  
  //player 1 movement
  if(keyCode == w || keyCode == a || keyCode == s || keyCode == d){
    //check case where out of bounds
    //change the field for player1Row

   if (keyCode == w && player1Row > 0){
    player1Row--;
   }
   if (keyCode == a && player1Col > 0) {
    player1Col--;
   }
   if (keyCode == s && player1Row < maximumx-1) {
    player1Row++;
   }
   if (keyCode == d && player1Col < maximumy-1){
    player1Col++;
   }
    System.out.println(player1Row);
    System.out.println(player1Col);
    //shift the player1 picture up in the 2D array
    int val = (int) (random(0, 100));
    System.out.println(val);
    GridLocation loc = new GridLocation(player1Row, player1Col);

    if (val == 99){      
      secret = false;
      debounce = true;
      player1 = loadImage("images/spook.png");
      player1.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
    }
    else {
      secret = true;
      
      
    }
        if (secret == true  && debounce == true){
          player1 = loadImage("images/x_wood.png");
          player1.resize(grid.getTileWidthPixels(),grid.getTileHeightPixels());
          debounce = false;
        }
        
         grid.setTileImage(loc,player1);

    
    
    

    //eliminate the picture from the old location

  }
  if(keyCode == up || keyCode == left || keyCode == down || keyCode == right){
   if (keyCode == up && player2Row > 0){
    player2Row--;
   }
   if (keyCode == left && player2Col > 0) {
    player2Col--;
   }
   if (keyCode == down && player2Row < maximumx-1) {
    player2Row++;
   }
   if (keyCode == right && player2Col < maximumy-1){
    player2Col++;
   }
    System.out.println(player2Row);
    System.out.println(player2Col);
    //shift the player1 picture up in the 2D array
    GridLocation loc = new GridLocation(player2Row, player2Col);
    grid.setTileImage(loc,player2);
  }
    

    
    
    

    //eliminate the picture from the old location

  }
  //Known Processing method that automatically will run when a mouse click triggers it
  public void mouseClicked(){
  
    //check if click was successful
    System.out.println("Mouse was clicked at (" + mouseX + "," + mouseY + ")");
    System.out.println("Grid location: " + grid.getGridLocation());

    //what to do if clicked? (Make player1 disappear?)


    //Toggle the animation on & off
    doAnimation = !doAnimation;
    System.out.println("doAnimation: " + doAnimation);
    grid.setMark("X",grid.getGridLocation());
    
  }





//------------------ CUSTOM  METHODS --------------------//

//method to update the Title Bar of the Game
public void updateTitleBar(){

  if(!isGameOver()) {
    //set the title each loop
    surface.setTitle(titleText + "    " + extraText);

    //adjust the extra text as desired
  
  }

}

//method to update what is drawn on the screen each frame
public void updateScreen(){

  //update the background
  background(bg);

  //Display the Player1 image
  GridLocation player1Loc = new GridLocation(player1Row,player1Col);
  grid.setTileImage(player1Loc, player1);
  GridLocation player2Loc = new GridLocation(player2Row,player2Col);
  grid.setTileImage(player2Loc, player2);
  //update other screen elements

}

//Method to populate enemies or other sprites on the screen
public void populateSprites(){

}

//Method to move around the enemies/sprites on the screen
public void moveSprites(){


}

//Method to handle the collisions between Sprites on the Screen
public void handleCollisions(){


}

//method to indicate when the main game is over
public boolean isGameOver(){
  return false; //by default, the game is never over
}

//method to describe what happens after the game is over
public void endGame(){
    System.out.println("Game Over!");

    //Update the title bar

    //Show any end imagery
    image(endScreen, 100,100);

}

//example method that creates 5 horses along the screen
public void exampleAnimationSetup(){  
  int i = 2;
  exampleSprite = new AnimatedSprite("sprites/horse_run.png", 50.0f, i*75.0f, "sprites/horse_run.json");
}

//example method that animates the horse Sprites
public void checkExampleAnimation(){
  if(doAnimation){
    exampleSprite.animateVertical(1.0f, 0.1f, true);
  }
}
/* Animated Sprite class - useful to have Sprites move around
 * Designed to be used with Spritesheets & JSON files from TexturePack software
 * Revised from Daniel Shiffman's p5js Animated Sprite tutorial
 * Author: Joel Bianchi
 * Last Edit: 5/17/2023

 * https://editor.p5js.org/codingtrain/sketches/vhnFx1mml
 * http://youtube.com/thecodingtrain
 * https://thecodingtrain.com/CodingChallenges/111-animated-sprite.html

 * Example Horse Spritesheet from
 * https://opengameart.org/content/2d-platformer-art-assets-from-horse-of-spring

 * Example Animated Sprite
 * https://youtu.be/3noMeuufLZY
 */
 
public class AnimatedSprite extends Sprite{
  
    private ArrayList<PImage> animation;
    private int w;
    private int h;
    private int len;
    private int index;

    JSONObject spriteData;
    PImage spriteSheet;

  // Constructor for AnimatedSprite with Spritesheet (Must use the TexturePacker to make the JSON)
  // https://www.codeandweb.com/texturepacker
  public AnimatedSprite(String png, float x, float y, String json) {
    super("none", x, y, 1.0f, true);

    this.animation = new ArrayList<PImage>();
 
    spriteData = loadJSONObject(json);
    spriteSheet = loadImage(png);
    JSONArray frames = spriteData.getJSONArray("frames");
    
    for(int i=0; i<frames.size(); i++){

      JSONObject frame = frames.getJSONObject(i);
      //System.out.println(i + ": " + frame + "\n");
      JSONObject fr = frame.getJSONObject("frame");
      //System.out.println("ss: " + fr + "\n");

      int sX = fr.getInt("x");
      int sY = fr.getInt("y");
      int sW = fr.getInt("w");
      int sH = fr.getInt("h");
      System.out.println(i + ":\t sX:" + sX + ":\t sY:" + sY + ":\t sW:" + sW + ":\t sH:" + sH);
      PImage img = spriteSheet.get(sX, sY, sW, sH);
      animation.add(img);

      this.w = this.animation.get(0).width;
      this.h = this.animation.get(0).height;
      this.len = this.animation.size();
      this.index = 0;
    }
  }

  //Overriden method: Displays the correct frame of the Sprite image on the screen
  public void show() {
    int index = (int) Math.floor(Math.abs(this.index)) % this.len;
    image(animation.get(index), super.getX(), super.getY());
    //System.out.println("Pos: "+ super.getX() +"," + super.getY());
  } 

  //Method to cycle through the images of the animated sprite
  public void animate(float animationSpeed){
    index += (int) (animationSpeed * 10);
    show();
  }

  //animated method that makes the Sprite move to the right-left
  public void animateHorizontal(float horizontalSpeed, float animationSpeed, boolean wraparound) {

    //adjust speed & frames
    animate(animationSpeed);
    super.move( (int) (horizontalSpeed * 10), 0 );
  
    //wraparound sprite if goes off the right or left
    if(wraparound){
      wraparoundHorizontal();
    }

  }

  //animated method that makes the Sprite move down-up
  public void animateVertical(float verticalSpeed, float animationSpeed, boolean wraparound) {

    //adjust speed & frames
    animate(animationSpeed);
    super.move( 0, (int) (verticalSpeed * 10));
  
    //wraparound sprite if goes off the bottom or top
    if(wraparound){
      wraparoundVertical();
    }
  }

  //wraparound sprite if goes off the right-left
  private void wraparoundHorizontal(){
    if ( super.getX() > width ) {
      super.setX( -this.w );
    } else if ( super.getX() < -width ){
      super.setX( width );
    }
  }

  //wraparound sprite if goes off the top-bottom
  private void wraparoundVertical(){
    if ( super.getY() > height ) {
      super.setY( -this.h );
    } else if ( super.getY() < -height ){
      super.setY( height );
    }
  }


}
/* Grid Class - Used for rectangular-tiled games
 * A 2D array of GridTiles which can be marked
 * Author: Joel Bianchi
 * Last Edit: 5/17/2023
 * Edited to integrate with HexTile
 */

public class Grid{
  
  private int rows;
  private int cols;
  private GridTile[][] board;
  

  //Grid constructor that will create a Grid with the specified number of rows and cols
  public Grid(int rows, int cols){
    this.rows = rows;
    this.cols = cols;
    board = new GridTile[rows][cols];
    
    for(int r=0; r<rows; r++){
      for(int c=0; c<cols; c++){
        board[r][c] = new GridTile(new GridLocation(r,c));
      }
    }
  }

  // Default Grid constructor that creates a 3x3 Grid  
  public Grid(){
     this(3,3);
  }

  // Method that Assigns a String mark to a location in the Grid.  
  // This mark is not necessarily visible, but can help in tracking
  // what you want recorded at each GridLocation.
  public void setMark(String mark, GridLocation loc){
    board[loc.getR()][loc.getC()].setNewMark(mark);
    printGrid();
  } 

  // Method that Assigns a String mark to a location in the Grid.  
  // This mark is not necessarily visible, but can help in tracking
  // what you want recorded at each GridLocation.  
  // Returns true if mark is correctly set (no previous mark) or false if not
  public boolean setNewMark(String mark, GridLocation loc){
    int row = loc.getR();
    int col = loc.getC();
    boolean isGoodClick = board[row][col].setNewMark(mark);
    printGrid();
    return isGoodClick;
  } 
  
  //Method that prints out the marks in the Grid to the console
  public void printGrid(){
   
    for(int r = 0; r<rows; r++){
      for(int c = 0; c<cols; c++){
         System.out.print(board[r][c]);
      }
      System.out.println();
    } 
  }
  
  //Method that returns the GridLocation of where the mouse is currently hovering over
  public GridLocation getGridLocation(){
      
    int row = mouseY/(pixelHeight/this.rows);
    int col = mouseX/(pixelWidth/this.cols);

    return new GridLocation(row, col);
  } 

  //Accessor method that provide the x-pixel value given a GridLocation loc
  public int getX(GridLocation loc){
    int widthOfOneTile = pixelWidth/this.cols;
    //calculate the left of the grid GridLocation
    int pixelX = (widthOfOneTile * loc.getC()); 
    return pixelX;
  }
  public int getX(int row, int col){
    return getX(new GridLocation(row, col));
  }
  
  //Accessor method that provide the y-pixel value given a GridLocation loc
  public int getY(GridLocation loc){
    int heightOfOneTile = pixelHeight/this.rows;
    //calculate the top of the grid GridLocation
    int pixelY = (heightOfOneTile * loc.getR()); 
    return pixelY;
  }
  public int getY(int row, int col){
    return getY(new GridLocation(row,col));
  }

  
  //Accessor method that returns the number of rows in the Grid
  public int getRows(){
    return rows;
  }
  
  //Accessor method that returns the number of cols in the Grid
  public int getCols(){
    return cols;
  }

  //Accessor method that returns the width of 1 Tile in the Grid
  public int getTileWidthPixels(){
    return pixelWidth/this.cols;
  }
  //Accessor method that returns the height of 1 Tile in the Grid
  public int getTileHeightPixels(){
    return pixelHeight/this.cols;
  }


  //Returns the GridTile object stored at a specified GridLocation
  public GridTile getTile(GridLocation loc){
    return board[loc.getR()][loc.getC()];
  }

  //Returns the GridTile object stored at a specified row and column
  public GridTile getTile(int r, int c){
    return board[r][c];
  }

  //Method that sets the image at a particular tile in the grid & displays it
  public void setTileImage(GridLocation loc, PImage pi){
    GridTile tile = getTile(loc);
    tile.setImage(pi);
    image(pi,getX(loc),getY(loc));
    //System.out.println("Setting Tile Image: " + getX(loc) + "," + getY(loc));
  }

  //Method that returns the PImage associated with a particular Tile
  public PImage getTileImage(GridLocation loc){
    GridTile tile = getTile(loc);
    return tile.getImage();
  }

  
}
/* GridLocation class - helper class to store coordinates more easily
 * Author: Joel Bianchi
 * Last Edit: 5/17/2023
 */

public class GridLocation{
 
  int row;
  int col;
  
  public GridLocation(int row, int col){
    this.row = row;
    this.col = col;
  }
  
  public int getR(){
    return row;
  }
  
  public int getC(){
    return col;
  }
  
  public String toString(){
    return row + "," + col;
  }
  
  public int getYCoord() {
    return -1;
  }
  
  public int getXCoord() {
    return -1;
  }
 
}
/* GridTile class - Designed to be used within the Grid class
 * GridTiles have distinguishable marks that will be printed out to the console for easy visualization of a 2D array
 * GridTiles can indicate if they have been "captured", colored, or are displaying an image
 * Authors: Joel Bianchi, Naomi Gaylor, Ezzeldin Moussa
 * Last Edit: 5/17/2023
 * Edited to be superclass of HexTile
 */



public class GridTile{
  
  private GridLocation location;
  private PImage pi;
  private boolean coveredPic;
  private int fillColor;
  final int defaultFillColor = 0xFFFFFFFF; //WHITE
  private int outlineColor;
  final int defaultOutlineColor = 0xFF000000; //BLACK
  private String mark;
  final private static String noMark = " ";
  private boolean isCaptured;

  //GridTile constructor #1: Adds the specified String mark
  public GridTile(String mark, GridLocation loc){
    this.mark = mark;
    location = loc;
    fillColor = defaultFillColor;
    outlineColor = defaultOutlineColor;
    coveredPic = false; 
  }
  
  //GridTile constructor #2 which adds a mark, but no Location
  public GridTile(String mark){
    this(mark, null);
  }

  //GridTile constructor #3 which adds a GridLocation, but no mark  
  public GridTile(GridLocation loc){
    this(noMark, loc);
  }

  //Default GridTile constructor which puts an empty String mark in the GridTile
  public GridTile(){
    this(noMark, null);
  }

  // Accessor method that gets the mark in the GridTile
  public String getMark(){
    return mark;
  }
  
  // Mutator method that automatically changes the mark
  public void setMark(String mark){
    this.mark = mark;
  }

  // Mutator method sets a new mark in the GridTile 
  // if it does not already have a mark, 
  // returns true or false if successful
  public boolean setNewMark(String mark){
    if(this.mark.equals(noMark)){
      this.mark = mark;
      System.out.println("Successfully changed mark");
      return true;
    } else {
      System.out.println("That GridTile is already taken!");
      return false;
    }
  }
  
  // Mutator method that sets an new PImage in the GridTile
  public void setImage(PImage pi){
    this.pi = pi;
  }

  //Accessor method that returns the PImage stored in the GridTile
  public PImage getImage(){
    return pi;
  }

  //method to "capture" a tile by changing its color
  public void captureTile(int clr){
    this.isCaptured = false;
    this.fillColor = clr;
  }

  //method to "release" a tile by changing its color
  public void releaseTile(){
    this.isCaptured = false;
    this.fillColor = defaultFillColor;
  }

  //accessor method to check if tile is captured
  public boolean checkIsCaptured(){
    return isCaptured;
  }

  //method to access the location of the GridTile
  public GridLocation getLocation(){
      return location;
  }

  //method to change the color of the tile
  public void setColor(int clr) {
    this.fillColor = clr;
  }

  //method to access the color of the tile
  public int getColor() {
    return fillColor;
  }

  public void setOutlineColor(int oclr){
    this.outlineColor = oclr;
  }

  public int getOutlineColor(){
    return this.outlineColor;
  }

  public void setCoveredWithPic(boolean isCoveredWithPic) {
    this.coveredPic = isCoveredWithPic;
  }

  public boolean isCoveredWithPic() {
    return this.coveredPic;
  }

  //ToString simply retuns the mark on the Tile, useful for printing out 2D grids
  public String toString(){
    return mark;
  }


}
/* HexGrid Class - useful for tile-based games with more flavor!
 * Inspired from CSRessel's Catan Game & Emmanuel Suriel's Grid class
 * https://github.com/CSRessel/catan/blob/master/src/gui/CatanBoard.java
 * Adapted for Processing
 * Authors: Joel Bianchi, Naomi Gaylor, Ezzeldin Moussa
 * Last Edit: 5/16/2023
 * NOT FULLY FUNCTIONAL YET
 */





public class HexGrid {

	ArrayList<HexLocation> allHexLocations;
	ArrayList<HexLocation> unclaimedLocations;
	
    private HexTile[][] map;
    private int defaultOutlineColor = 0xFFFFFFFF;	//WHITE
    private int defaultFillColor = 0xFF000000; 		//BLACK
	private int defaultBgColor = color(164,200,218);
	
	private boolean bgSet = false;

    //GUI fields
	private int hexGen;
	private int hexDiameter;
	private int boardHeight;
	private int hexagonSide;
	private int heightMargin = 100;
	private int widthMargin;
	private final double sqrt3div2 = 0.86602540378f;

    //HexGrid Constructor
    public HexGrid(int hexGen){

		this.hexGen = hexGen;

		//Generate all the valid hexLocations
		allHexLocations = new ArrayList<HexLocation>();
        
		hexDiameter = hexGen *2 -1;	//originally 5
		int midHex = hexGen;	//originally 3
		System.out.println("mid:" + midHex);

		//Create top half of HexLocations
		for(int r=1; r <= midHex; r++){
			for(int c=1; c <= midHex + r - 1; c++){
				allHexLocations.add( new HexLocation(c,r) );
			}
		}
		//Create bottom half of HexLocations
		for(int r = midHex +1; r <= hexDiameter; r++){
			for(int c= r-midHex + 1; c <= hexDiameter; c++){
				allHexLocations.add( new HexLocation(c,r) );
			}
		}
		
		System.out.println("All generated HexLocations:");
		System.out.println(allHexLocations);

		//Construct 2D array of HexTiles
		int row = hexDiameter + 2;
		int col = row;
        map = new HexTile[row][col];

		//Initialize unclaimed HexLocations arrayList
		unclaimedLocations = new ArrayList<HexLocation>();

		for(HexLocation loc: allHexLocations){

			//Generate hexTiles for each HexLocation
			HexTile hTile = new HexTile(loc, this.hexDiameter);
			map[loc.getYCoord()][loc.getXCoord()] = hTile;
			hTile.setColor(defaultFillColor);
			hTile.setOutlineColor(defaultOutlineColor);
			setHexTileCenterPixels(hTile);
			setHexTilePoly(hTile);

			//Generate unclaimedTiles ArrayList
			unclaimedLocations.add(loc);
		}
    }

	public boolean isValidLocation(HexLocation testLoc){
		for(int i=0; i<unclaimedLocations.size(); i++){
			if(unclaimedLocations.get(i).equals(testLoc)){
				return true;
			}
		}
		return false;
	}

	public boolean isWithinOne(HexLocation start, HexLocation end){
		int startX = start.getXCoord();
		int startY = start.getYCoord();
		int endX = end.getXCoord();
		int endY = end.getYCoord();

		if(endX==startX+1 || endX==startX-1 || endX==startX){
			if(endY==startY+1 || endY==startY-1 || endY==startY){
				return true;
			}
		}
		return false;
	}

	public boolean isWithinTwo(HexLocation start, HexLocation end){
		int startX = start.getXCoord();
		int startY = start.getYCoord();
		int endX = end.getXCoord();
		int endY = end.getYCoord();

		if(endX==startX+2 || endX==startX+1 || endX==startX-2 || endX==startX-1 || endX==startX){
			if(endY==startY+2 || endY==startY+1 || endY==startY-2 || endY==startY-1 || endY==startY){
				return true;
			}
		}
		return false;
	}

	public void removeHexLocation(HexLocation loc){
		for(int i=0; i<unclaimedLocations.size(); i++){
      		if(unclaimedLocations.get(i).equals(loc)){
        		unclaimedLocations.remove(i);
				return;
			}
		}
		System.out.println("Error when trying to remove Location: " + loc);
	}


	public void displayHexGrid(){

        int mapHeight = map.length;
        //int hexagonSide = 50;
		//int hexagonSide = (mapHeight - 2 * heightMargin) / 8;
        int widthMargin = (width - (int) (10 * hexagonSide * sqrt3div2)) / 2;

        // Graphics2D g2 = (Graphics2D)g;
        // g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        // g.setFont(new Font("TimesRoman", Font.PLAIN, 20));
        // super.paintComponent(g2);

		//System.out.println("ahl size: " + allHexLocations.size());

		//Fill in each Hex
		for(HexLocation loc: allHexLocations){
			int x = loc.getXCoord();
			int y = loc.getYCoord();
			HexTile hTile = map[x][y];
			//System.out.println(hTile);
			fillOneHex(hTile);
		}

		//Outline each Hex
		for(HexLocation loc: allHexLocations){
			int x = loc.getXCoord();
			int y = loc.getYCoord();
			HexTile hTile = map[x][y];
			outlineOneHex(hTile);
		}

		//System.out.println("HexLocations: " + hexLocations);
    }

	private void setHexTileCenterPixels(HexTile hTile){
		int x = hTile.getLocation().getXCoord();
        int y = hTile.getLocation().getYCoord();
		Point centerPixels = findTileCenter(hTile);
		hTile.setHexCenterPixels(centerPixels);
	}

	private void setHexTilePoly(HexTile hTile){
        Polygon hexPoly = makeHex(hTile.getCenterPixels());
		hTile.setHexPoly(hexPoly);
	}

	//method to fill in 1 hex tile
    public void fillOneHex(HexTile hTile){

        boolean hasImage = hTile.isCoveredWithPic();
		//System.out.println("drawHex: x:"+tile.getLocation().getXCoord()+",y:"+tile.getLocation().getYCoord());
		
        //FILL IN SOLID COLOR - fill in hexTile with a solid color if no picture
        if(!hasImage){
			int fillClr = hTile.getColor();
			
			// ???

		}
    		
        //FILL IN PICTURE
        if(hasImage){    
			PImage photo = hTile.getImage();
			
			try{
				//resize the image to fit in the hex
				int iSize = (int) (hexagonSide * 1.25f);
				photo.resize(iSize, iSize);

				//mask the image to the hex shape
				PGraphics maskImage;
				maskImage = createGraphics(iSize,iSize);
				maskImage.beginDraw();
				//maskImage.triangle(30, 480, 256, 30, 480, 480);
				//maskImage = drawOneHex(PGraphics maskImage);
				maskImage.endDraw();
				
				// apply mask
				photo.mask(maskImage);

				//display masked image
				image(photo, 0, 0);

				final int ix = getImageX(hTile, photo);
				final int iy = getImageY(hTile, photo);
				
				//System.out.println("Img: " + locImageName);
				//System.out.println("nPoints:" + poly.npoints);
				//System.out.println("ix:" + ix + "\tiy:"+iy);

				//System.out.println("Drew image for x:" + x + ",y:" + y);

			} catch(Exception e){

			} //end catch
		} //end image fill
	} //end drawing one hex

	//method to draw the outline around a hex tile
    public void outlineOneHex(HexTile hTile){
		int oClr = hTile.defaultOutlineColor;
		float stroke = 3.0f;
		int tileOutlineColor = hTile.getOutlineColor();
		
		if(tileOutlineColor != oClr){
			PGraphics pg = getHexPGraphics(hTile);

			//DRAW THE OUTLINE!???

		}
	}


//---------------------- HELPER METHODS -------------------------------//
    private int getImageX(HexTile hTile, PImage image){
    	Point center = findTileCenter(hTile);
        int imageWidth =  image.width;
        return center.x - imageWidth/2; 
    }
    private int getImageY(HexTile hTile, PImage image){        
        Point center = findTileCenter(hTile);
        int imageHeight =  image.height;
        return center.y - imageHeight/2; 
    }

	//method finds the center pixels of a HexTile based on its grid coordinates
	private Point findTileCenter(HexTile hTile){
		return findTileCenter(hTile.getLocation().getXCoord(), hTile.getLocation().getYCoord());
	}
	private Point findTileCenter(int xcoord, int ycoord){
		int x = xcoord;
		int y = ycoord;
		//code for a bottom left origin with rows as x and cols as y
		// int xCenter = widthMargin + (int) (3 * hexagonSide * sqrt3div2)
		// 		+ (int) ((x - 1) * 2 * hexagonSide * sqrt3div2)
		// 		- (int) ((y - 1) * hexagonSide * sqrt3div2);
		// int yCenter = boardHeight - (heightMargin + hexagonSide
		// 		+ (int) ((y - 1) * hexagonSide * 1.5));

		//code for a top left origin (to mimic how Java 2D arrays are modeled) with rows as y and cols as x
		int xCenter = widthMargin + (int) (3 * hexagonSide * sqrt3div2)
		+ (int) ((x - 1) * 2 * hexagonSide * sqrt3div2)
		- (int) ((y - 1) * hexagonSide * sqrt3div2);
		
		int yCenter = (heightMargin + hexagonSide 
		+ (int) ((y - 1) * hexagonSide * 1.5f));

		return new Point(xCenter,yCenter);
	}



    //MUTATOR METHODS
    public void setAllTileColors(int tileColor){
        this.defaultFillColor = tileColor;
          for (int r = 0; r < map.length; r++) {
            for (int c = 0; c < map[0].length; c++) {
                if (map[r][c] != null){
                    map[r][c].setColor(defaultFillColor);
                }
            }
        }
    }

	public void setAllTileOutlines(int outlineColor){
        this.defaultFillColor = outlineColor;
          for (int r = 0; r < map.length; r++) {
            for (int c = 0; c < map[0].length; c++) {
                if (map[r][c] != null){
                    map[r][c].setOutlineColor(defaultFillColor);
                }
            }
        }


    }


	//method to access any Hextile based on its location
    public HexTile getHexTile(HexLocation loc){
		int x = loc.getXCoord();
		int y = loc.getYCoord();
        return map[x][y];
    }

    public int setTileColor(HexLocation loc, int tileColor){
		HexTile hTile = getHexTile(loc);
        int oldColor = hTile.getColor();
        hTile.setColor(tileColor);
        return oldColor;
    }

	public void highlightTile(HexLocation loc) {
		HexTile hTile = getHexTile(loc);
		int highlightColor = 0xFFFFFFFF;

		Point p = hTile.getCenterPixels();

		//Shape shape = new Ellipse2D.Double((int)p.getX() - 25, (int)p.getY() - 25, 50, 50);

		// g2.setColor(Color.WHITE);
		// g2.fill(shape);
		// g2.draw(shape);
	}
    


    /* ---------------  HEX GRID ACCESSOR METHODS ------------------ */
	public HexTile[][] getMap(){
        return map;
    }
    
    public int getNumRows() {
		return map.length;
	}

	public int getNumCols() {
		return map[0].length;
	}

    //needs to be modified slightly because HexGrid doesn't include ALL tiles in the rectangle (like 0,0)
	public boolean isValid(final HexLocation loc) {
		final int row = loc.getYCoord();
		final int col = loc.getXCoord();
		return 0 <= row && row < getNumRows() && 0 <= col && col < getNumCols();
	}


    /* ---------------- BACKGROUND IMAGE METHODS ------------------------- */



	/**
	 * sets the background to imgName. The img is resized to fit in the grids
	 * dimensions. setColor() is disabled
	 * 
	 * @param imgName
	 */
	public void setBackground(PImage bgImage) {
		// this.xOffset = 0;
		// this.yOffset = 0;
		// this.xScale = 1.0;
		// this.yScale = 1.0;

		// backgroundImage = loadImage(imgName);
		// bgSet = true;

		//repaint();
	}

	/**
	 * Removes a regular background or moveable background, allowing setColor to
	 * work again.
	 */
	public void removeBackground() {
		bgSet = false;
	}



	public void setFillColor(final HexLocation loc, final int clr) {
		if (!isValid(loc))
			throw new RuntimeException("cannot set color of invalid location " + loc + " to color " + clr);
		map[loc.getXCoord()][loc.getYCoord()].setColor(clr);
		//repaint();
	}

	public int getFillColor(final HexLocation loc) {
		if (!isValid(loc))
			throw new RuntimeException("cannot get color from invalid location " + loc);
		return map[loc.getYCoord()][loc.getXCoord()].getColor();
	}

	// public void setImage(final HexLocation loc, final String imageFileName) {
	// 	if (!isValid(loc))
	// 		throw new RuntimeException(
	// 				"cannot set image for invalid location " + loc + " to \"" + imageFileName + "\"");
	// 	map[loc.getXCoord()][loc.getYCoord()].setImageFileName(imageFileName);
	// 	repaint();
	// }

	// public String getImage(final Location loc) {
	// 	if (!isValid(loc))
	// 		throw new RuntimeException("cannot get image for invalid location " + loc);
	// 	return map[loc.getYCoord()][loc.getXCoord()].getImageFileName();
	// }

	public void setTileOutlineColor(final HexLocation loc, final int oclr) {
		if (!isValid(loc))
			throw new RuntimeException("cannot set outline for invalid location " + loc);
            map[loc.getXCoord()][loc.getYCoord()].setOutlineColor(oclr);
		//repaint();
	}

	public int getTileOutlineColor(final HexLocation loc) {
		if (!isValid(loc))
			throw new RuntimeException("cannot get outline color for invalid location " + loc);
		return map[loc.getXCoord()][loc.getYCoord()].getOutlineColor();
	}

	public void setAllOutlinesColor(final int oclr) {
		for (int r = 0; r < getNumRows(); r++) {
			for (int c = 0; c < getNumCols(); c++) {
				map[r][c].setOutlineColor(oclr);
			}
		}
		//repaint();
	}



    /* ----- INPUT HANDLING -------------------------------------------------------------------- */
	// // returns -1 if no key pressed since last call.
	// // otherwise returns the code for the last key pressed.
	// public int checkLastKeyPressed() {
	// 	final int key = lastKeyPressed;
	// 	lastKeyPressed = -1;
	// 	return key;
	// }

	// // returns null if no location clicked since last call.
	// public HexLocation checkLastLocationClicked() {
	// 	final HexLocation loc = lastLocationClicked;
	// 	lastLocationClicked = null;
	// 	return loc;
	// }

	// public HexLocation waitForClick() {
	// 	while (true) {
	// 		final HexLocation clicked = this.checkLastLocationClicked();
	// 		if (clicked != null) {
	// 			//System.out.print("x:"+clicked.getXCoord()+ ",y:" + clicked.getYCoord());
	// 			return clicked;
	// 		} else {
	// 			//System.out.print("NOT CLICKED");
	// 			HexGrid.pause(100);
	// 		}
	// 	}
	// }

    // public static void pause(final int milliseconds) {
	// 	try {
	// 		Thread.sleep(milliseconds);
	// 	} catch (final Exception e) {
	// 		// ignore
	// 	}
	// }

    // public void keyPressed(final KeyEvent e) {
	// 	lastKeyPressed = e.getKeyCode();
	// }

	// public void mousePressed(final MouseEvent e) {

	// 	Point p = e.getPoint();
	// 	//System.out.println(p);
		
	// 	for(HexLocation loc : this.allHexLocations){
	// 		HexTile hTile = map[loc.getXCoord()][loc.getYCoord()];
	// 		Polygon hexPoly = hTile.getHexPoly();
	// 		if(hexPoly.contains(p)){
				
	// 			lastLocationClicked = loc;
				
	// 		}
	// 	}
	// }



    // ------------------ GUI HELPER METHODS --------------------------------------------------------------------------//

    // private void guiInit() {
    //     lastKeyPressed = -1;
    //     lastLocationClicked = null;

    //     frame = new JFrame("Grid");
    //     frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	// 	fullscreen();	//makes the it stay on the left??
    //     frame.addKeyListener(this);

    //     int mapSize = Math.max(Math.min(500 / getNumRows(), 500 / getNumCols()), 1);
    //     setPreferredSize(new Dimension(mapSize * getNumCols(), mapSize * getNumRows()));
    //     addMouseListener(this);
    //     frame.getContentPane().add(this);

    //     frame.pack();
    //     frame.setVisible(true);

	// 	setBackground(defaultBgColor); //TODO add background

	// 	boardHeight = getHeight();
	// 	hexagonSide = 250 / (hexGen + 2);
	// 	//hexagonSide = 25;
	// 	//hexagonSide = (boardHeight - 2 * heightMargin) / 8;
	// 	widthMargin = (getWidth() - (int) (10 * hexagonSide * sqrt3div2)) / 2;
	// 	System.out.println("Boardheight: " + boardHeight);
	// 	System.out.println("HexagonSide: " + hexagonSide);
	// 	System.out.println("WidthMargin: " + widthMargin);

	// 	this.addComponentListener(new ComponentListener() {

    // 		public void componentResized(ComponentEvent e) {
    // 		//	System.out.println(e.getComponent().getSize());
    // 			boardHeight = getHeight();
    // 			//hexagonSide = (boardHeight - 2 * heightMargin) / 8;
    // 			widthMargin = (getWidth() - (int) (10 * hexagonSide * sqrt3div2)) / 2;
    // 			//System.out.println("Boardheight: " + boardHeight);
    // 			//System.out.println("HexagonSide: " + hexagonSide);
    // 			//System.out.println("WidthMargin: " + widthMargin);
    // 		}

    // 		public void componentHidden(ComponentEvent e) {}

    // 		public void componentMoved(ComponentEvent e) {}

    // 		public void componentShown(ComponentEvent e) {}
    // 	});

    // }

    // private void load(String imageFileName) {
    //     showFullImage(loadImage(imageFileName));
    //     setTitle(imageFileName);
    // }

    // private void save(String imageFileName) {
    //     try {
    //         BufferedImage bi = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);
    //         paintComponent(bi.getGraphics());
    //         int index = imageFileName.lastIndexOf('.');
    //         if (index == -1)
    //             throw new RuntimeException("invalid image file name:  " + imageFileName);
    //         ImageIO.write(bi, imageFileName.substring(index + 1), new File(imageFileName));
    //     } catch ( IOException e) {
    //         throw new RuntimeException("unable to save image to file:  " + imageFileName);
    //     }
    // }

	// private BufferedImage loadImage(String imageFileName) {
		
	// 	if(imageFileName == null || "".equals(imageFileName)){
	// 		System.out.println("Image is null or \"\"");
	// 		return null;
	// 	} else{
	// 		final URL url = getClass().getResource(imageFileName);
	// 		if (url == null) {
	// 			throw new RuntimeException("cannot find file:  " + imageFileName);
	// 		}
	// 		try {
	// 			return ImageIO.read(url);
	// 		} catch (IOException e) {
	// 			throw new RuntimeException("unable to read from file:  " + imageFileName);
	// 		}
	// 	}
	// }


    // private void showFullImage(BufferedImage image) {
    //     for (int row = 0; row < getNumRows(); row++) {
    //         for (int col = 0; col < getNumCols(); col++) {
    //             int x = col * image.getWidth() / getNumCols();
    //             int y = row * image.getHeight() / getNumRows();
    //             int c = image.getRGB(x, y);

    //             int red = (c & 0x00ff0000) >> 16;
    //             int green = (c & 0x0000ff00) >> 8;
    //             int blue = c & 0x000000ff;

    //             map[row][col].setColor(new Color(red, green, blue));
    //         }
    //     }
    //     repaint();
    // }

  

	// private displayHexTile(){
	// 	pushMatrix();
	// 	translate(width*0.8, height*0.5);
	// 	polygon(0, 0, 70, 6);
	// 	popMatrix();
	// }

	//function that creates a n-sided polygon on a point circle
	private void hexagon(HexTile hTile) {
		int npoints = 6;
		float x = hTile.getCenterPixels().x;
		float y = hTile.getCenterPixels().y;
		float angle = TWO_PI / npoints;
		float radius = hTile.getRadius();
		beginShape();
		for (float a = 0; a < TWO_PI; a += angle) {
			float sx = x + cos(a) * radius;
			float sy = y + sin(a) * radius;
			vertex(sx, sy);
		}
		endShape(CLOSE);
	}



	public Polygon makeHex(Point center) {
		int xCenter = (int) center.getX();
		int yCenter = (int) center.getY();

		Polygon output = new Polygon();
		output.addPoint(xCenter + 1, yCenter + hexagonSide + 1);
		output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter + (int) (.5f * hexagonSide) + 1);
		output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter - (int) (.5f * hexagonSide) - 1);
		output.addPoint(xCenter + 1, yCenter - hexagonSide - 1);
		output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter - (int) (.5f * hexagonSide) - 1);
		output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter + (int) (.5f * hexagonSide) + 1);

		return output;
	}

	public PGraphics getHexPGraphics(HexTile hTile) {

		Point centerPixels = hTile.getCenterPixels();
		int xCenter = (int) centerPixels.getX();
		int yCenter = (int) centerPixels.getY();

		PGraphics pg = new PGraphics();

		// Polygon output = new Polygon();
		// output.addPoint(xCenter + 1, yCenter + hexagonSide + 1);
		// output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter + (int) (.5 * hexagonSide) + 1);
		// output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter - (int) (.5 * hexagonSide) - 1);
		// output.addPoint(xCenter + 1, yCenter - hexagonSide - 1);
		// output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter - (int) (.5 * hexagonSide) - 1);
		// output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter + (int) (.5 * hexagonSide) + 1);

		return pg;
	}

}  
/* HexLocation Class
 * HexLocations use x & y coordinate instead of row & column designations
 * Author: Joel Bianchi
 * Last Edit: 5/16/2023
 */

public class HexLocation extends GridLocation{
 
  private int xCoord;
  private int yCoord;
  
  public HexLocation(int x, int y) {
    super(x,y);
    xCoord = x;
    yCoord = y;
  }
  
  public int getYCoord() {
    return yCoord;
  }
  
  public int getXCoord() {
    return xCoord;
  }
  
  public boolean equals(HexLocation otherLoc) {
    return yCoord == otherLoc.getYCoord() && xCoord == otherLoc.getXCoord();
  }
  
  public String toString() {
    return "(" + xCoord + ", " + yCoord + ")";
  }


}
/* HexTile Class
 * Based off code from Naomi Gaylor & Ezzeldin Moussa, June 2022
 * Last edit: 5/16/2023
 * Edited to be a subclass of GridTile pde file
 */




public class HexTile extends GridTile{
  
  private Polygon hexPoly;
  private float radius;
  private Point centerPixels;
  //private HexLocation hexLoc;

  //HexTile Constructor #1: GridLocation
  public HexTile(HexLocation loc, float rad){
    super(loc);
    //this.hexLoc = loc;
    this.radius = rad;
    this.centerPixels = new Point(0,0);
    this.hexPoly = null;
  }

  //HexTile Constructor #2: X,Y coordinates
  public HexTile(int xCord, int yCord, float rad){
    this(new HexLocation(xCord,yCord), rad);
  }

  //method to access the location of the GridTile
  // public HexLocation getLocation(){
  //     return location;
  // }

  //mutator method to define the center point of the Tile
  public void setHexCenterPixels(Point centerPixels){
    this.centerPixels = centerPixels;
  }
  //accessor method to the center point of the Tile
  public Point getCenterPixels(){
    return centerPixels;
  }

  //mutator method to change the Java Polygon object that defines the shape of the HexTile
  public void setHexPoly(Polygon hexPoly){
    this.hexPoly = hexPoly;
  }
  //accessor method to return the Java Polygon object
  public Polygon getPoly(){
    return hexPoly;
  }

  //accessor method to return the hexagon's radius
  public float getRadius(){
    return radius;
  }

    
}  
/* Platform class
 * Stub constructors provided
 * Can be used with the following tutorials:
 * https://longbaonguyen.github.io/courses/platformer/platformer.html
 * Authors: __________________
 * Last Edit: 5/17/2023
 */

public class Platform {//extends Sprite {

	//Platform defined by it's center-x and top-Y positions
	public Platform(float posXCenter, float posYTop, float platWidth, float platHeight, int clr) {

		//pass along the center-x and center-y to Sprite super
		//super(posXCenter, posYTop + (platHeight/2), clr);
		//System.out.println("PlatTopY: " + posYTop + "\tPlatCenterY: " + (posYTop + (platHeight/2)));
		// setWidth(platWidth);
		// setHeight(platHeight);
		//setColor(Color.black);
	}

	public Platform(float posXCenter, float posYTop, float platWidth, float platHeight) {
		//pass along the center-x and center-y to Sprite super
		this(posXCenter, posYTop, platWidth, platHeight, color(0,0,0));
	}

}
/* Sprite class - to create objects that move around with their own properties
 * Inspired by Daniel Shiffman's p5js Animated Sprite tutorial
 * Author: Joel Bianchi
 * Last Edit: 12/20/2022
 */

public class Sprite {
  
    PImage spriteImg;
    private float center_x;
    private float center_y;
    private float speed_x;
    private float speed_y;
    private float w;
    private float h;
    private boolean isAnimated;


  // Main Constructor
  public Sprite(String spriteImgPath, float scale, float x, float y, boolean isAnimated) {
    this.center_x = x;
    this.center_y = y;
    this.speed_x = 0;
    this.speed_y = 0;
    this.isAnimated = isAnimated;
    if(!isAnimated){
      this.spriteImg = loadImage(spriteImgPath);
      w = spriteImg.width * scale;
      h = spriteImg.height * scale;
    }
  }

  // Simpler Constructor for Non-Animated Sprite
  public Sprite(String spriteImg, float x, float y) {
    this(spriteImg, 1.0f, x, y, false);
  }


  // method to display the Sprite image on the screen
  public void show() {
      image(spriteImg, this.center_x, this.center_y, w, h);
  }

  // method to move Sprite image on the screen to a specific coordinate
  public void moveTo(float x, float y){
    this.center_x = x;
    this.center_y = y;
  }

  // method to move Sprite image on the screen relative to current position
  public void move(float change_x, float change_y){
    this.center_x += change_x;
    this.center_y += change_y;
  }

  // method that automatically moves the Sprite based on its velocity
  public void update(){
    move(speed_x, speed_y);
  }


  // method to rotate Sprite image on the screen
  public void rotate(float degrees){

  }


  /*-- ACCESSOR METHODS --*/
  public float getX(){
    return center_x;
  }
  public float getY(){
    return center_y;
  }
  public PImage getImg(){
    return spriteImg;
  }
  public boolean getIsAnimated(){
    return isAnimated;
  }
  
  
  /*-- MUTATOR METHODS --*/
  public void setX(float x){
    this.center_x = x;
  }
  public void setY(float y){
    this.center_y=y;
  }
  public void setImg(PImage img){
    this.spriteImg = img;
  }
  public void setIsAnimated(boolean a){
    isAnimated = a;
  }


  /*-- SPRITE BOUNDARY METHODS --
    -- Used from Long Bao Nguyen
    -- https://longbaonguyen.github.io/courses/platformer/platformer.html
  */
  public void setLeft(float left){
    center_x = left + w/2;
  }
  public float getLeft(){
    return center_x - w/2;
  }
  public void setRight(float right){
    center_x = right - w/2;
  }
  public float getRight(){
    return center_x + w/2;
  }
  public void setTop(float top){
    center_y = top + h/2;
  }
  public float getTop(){
    return center_y - h/2;
  }
  public void setBottom(float bottom){
    center_y = bottom - h/2;
  }
  public float getBottom(){
    return center_y + h/2;
  }
  

}


  public void settings() { size(800, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Game" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
